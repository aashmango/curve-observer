"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/CurveCanvas.tsx":
/*!****************************************!*\
  !*** ./app/components/CurveCanvas.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CurveCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/canvasUtils */ \"(app-pages-browser)/./app/lib/canvasUtils.ts\");\n/* harmony import */ var _lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/curveRendering */ \"(app-pages-browser)/./app/lib/curveRendering.ts\");\n/* harmony import */ var _lib_curveCalculations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/curveCalculations */ \"(app-pages-browser)/./app/lib/curveCalculations.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction CurveCanvas(param) {\n    let { curveType, parameters, onParameterChange } = param;\n    _s();\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [dimensions, setDimensions] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        width: 0,\n        height: 0\n    });\n    const [draggingPoint, setDraggingPoint] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n    const padding = 60;\n    const xMin = -10;\n    const xMax = 10;\n    const yMin = -10;\n    const yMax = 10;\n    const config = {\n        padding,\n        xMin,\n        xMax,\n        yMin,\n        yMax,\n        dimensions\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const updateDimensions = ()=>{\n            if (canvasRef.current) {\n                const { width, height } = canvasRef.current.getBoundingClientRect();\n                setDimensions({\n                    width,\n                    height\n                });\n                (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.setupCanvas)(canvasRef.current);\n            }\n        };\n        window.addEventListener(\"resize\", updateDimensions);\n        updateDimensions();\n        return ()=>window.removeEventListener(\"resize\", updateDimensions);\n    }, []);\n    const handleMouseDown = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1) {\n            setDraggingPoint({\n                index: pointIndex,\n                point: controlPoints[pointIndex]\n            });\n        }\n    };\n    const handleDoubleClick = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const newPoint = {\n            x,\n            y\n        };\n        // Find the closest line segment to insert the new point\n        let minDist = Infinity;\n        let insertIndex = 0;\n        for(let i = 0; i < controlPoints.length - 1; i++){\n            const p1 = controlPoints[i];\n            const p2 = controlPoints[i + 1];\n            const dist = (0,_lib_curveCalculations__WEBPACK_IMPORTED_MODULE_4__.distanceToLineSegment)(x, y, p1.x, p1.y, p2.x, p2.y);\n            if (dist < minDist) {\n                minDist = dist;\n                insertIndex = i + 1;\n            }\n        }\n        // If no line segments found, append to the end\n        if (controlPoints.length === 0) {\n            insertIndex = 0;\n        }\n        const newPoints = [\n            ...controlPoints\n        ];\n        newPoints.splice(insertIndex, 0, newPoint);\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleContextMenu = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        e.preventDefault();\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1 && controlPoints.length > 2) {\n            const newPoints = [\n                ...controlPoints\n            ];\n            newPoints.splice(pointIndex, 1);\n            onParameterChange({\n                bezier: {\n                    ...parameters.bezier,\n                    controlPoints: newPoints\n                }\n            });\n        }\n    };\n    const handleMouseMove = (e)=>{\n        if (!draggingPoint || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const newPoints = [\n            ...parameters.bezier.controlPoints\n        ];\n        newPoints[draggingPoint.index] = {\n            x,\n            y\n        };\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleMouseUp = ()=>{\n        setDraggingPoint(null);\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.getCanvasContext)(canvas);\n        if (!ctx) return;\n        // Clear canvas\n        ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n        // Draw grid\n        (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawGrid)(ctx, config);\n        // Draw curve\n        (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawCurve)(ctx, curveType, parameters, config);\n        // Draw control points for BÃ©zier curves\n        if (curveType === \"bezier\" && parameters.bezier) {\n            (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawControlPoints)(ctx, parameters.bezier.controlPoints, config);\n        }\n    }, [\n        curveType,\n        parameters,\n        dimensions\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"h-full w-full rounded-lg border bg-background\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu\n    }, void 0, false, {\n        fileName: \"/Users/agoghari/curve-explorer/app/components/CurveCanvas.tsx\",\n        lineNumber: 195,\n        columnNumber: 5\n    }, this);\n}\n_s(CurveCanvas, \"YabCTyuMquUxp7gR26CrjMOV5Fg=\");\n_c = CurveCanvas;\nvar _c;\n$RefreshReg$(_c, \"CurveCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0N1cnZlQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFOEI7QUFFMEU7QUFDMUI7QUFDZDtBQVFqRCxTQUFTUyxZQUFZLEtBQThEO1FBQTlELEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxpQkFBaUIsRUFBb0IsR0FBOUQ7O0lBQ2xDLE1BQU1DLFlBQVliLHlDQUFZLENBQW9CO0lBQ2xELE1BQU0sQ0FBQ2UsWUFBWUMsY0FBYyxHQUFHaEIsMkNBQWMsQ0FBQztRQUFFa0IsT0FBTztRQUFHQyxRQUFRO0lBQUU7SUFDekUsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR3JCLDJDQUFjLENBQXlDO0lBRWpHLE1BQU1zQixVQUFVO0lBQ2hCLE1BQU1DLE9BQU8sQ0FBQztJQUNkLE1BQU1DLE9BQU87SUFDYixNQUFNQyxPQUFPLENBQUM7SUFDZCxNQUFNQyxPQUFPO0lBRWIsTUFBTUMsU0FBUztRQUNiTDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBWDtJQUNGO0lBRUFmLDRDQUFlLENBQUM7UUFDZCxNQUFNNkIsbUJBQW1CO1lBQ3ZCLElBQUloQixVQUFVaUIsT0FBTyxFQUFFO2dCQUNyQixNQUFNLEVBQUVaLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdOLFVBQVVpQixPQUFPLENBQUNDLHFCQUFxQjtnQkFDakVmLGNBQWM7b0JBQUVFO29CQUFPQztnQkFBTztnQkFDOUJsQiw2REFBV0EsQ0FBQ1ksVUFBVWlCLE9BQU87WUFDL0I7UUFDRjtRQUVBRSxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVSjtRQUNsQ0E7UUFFQSxPQUFPLElBQU1HLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVMO0lBQ3BELEdBQUcsRUFBRTtJQUVMLE1BQU1NLGtCQUFrQixDQUFDQztRQUN2QixJQUFJMUIsY0FBYyxZQUFZLENBQUNDLFdBQVcwQixNQUFNLEVBQUU7UUFFbEQsTUFBTUMsU0FBU3pCLFVB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TUFBTTtnQkFDcEJTLGVBQWVtQjtZQUNqQjtRQUNGO0lBQ0Y7SUFFQSxNQUFNSyxnQkFBZ0I7UUFDcEJqRCxpQkFBaUI7SUFDbkI7SUFFQXJCLDRDQUFlLENBQUM7UUFDZCxNQUFNc0MsU0FBU3pCLFVBQVVpQixPQUFPO1FBQ2hDLElBQUksQ0FBQ1EsUUFBUTtRQUViLE1BQU1pQyxNQUFNckUsa0VBQWdCQSxDQUFDb0M7UUFDN0IsSUFBSSxDQUFDaUMsS0FBSztRQUVWLGVBQWU7UUFDZkEsSUFBSUMsU0FBUyxDQUFDLEdBQUcsR0FBR3pELFdBQVdHLEtBQUssRUFBRUgsV0FBV0ksTUFBTTtRQUV2RCxZQUFZO1FBQ1pkLDZEQUFRQSxDQUFDa0UsS0FBSzVDO1FBRWQsYUFBYTtRQUNickIsOERBQVNBLENBQUNpRSxLQUFLN0QsV0FBV0MsWUFBWWdCO1FBRXRDLHdDQUF3QztRQUN4QyxJQUFJakIsY0FBYyxZQUFZQyxXQUFXMEIsTUFBTSxFQUFFO1lBQy9DOUIsc0VBQWlCQSxDQUFDZ0UsS0FBSzVELFdBQVcwQixNQUFNLENBQUNTLGFBQWEsRUFBRW5CO1FBQzFEO0lBQ0YsR0FBRztRQUFDakI7UUFBV0M7UUFBWUk7S0FBVztJQUV0QyxxQkFDRSw4REFBQ3VCO1FBQ0NtQyxLQUFLNUQ7UUFDTDZELFdBQVU7UUFDVkMsYUFBYXhDO1FBQ2J5QyxhQUFhUDtRQUNiUSxXQUFXUDtRQUNYUSxjQUFjUjtRQUNkUyxlQUFleEI7UUFDZnlCLGVBQWViOzs7Ozs7QUFHckI7R0EvTHdCMUQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvQ3VydmVDYW52YXMudHN4P2Y0NTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ3VydmVQYXJhbWV0ZXJzLCBDdXJ2ZVR5cGUsIFBvaW50IH0gZnJvbSAnLi4vdHlwZXMvY3VydmVzJ1xuaW1wb3J0IHsgc2V0dXBDYW52YXMsIGdldENhbnZhc0NvbnRleHQsIGludmVyc2VUcmFuc2Zvcm1YLCBpbnZlcnNlVHJhbnNmb3JtWSB9IGZyb20gJy4uL2xpYi9jYW52YXNVdGlscydcbmltcG9ydCB7IGRyYXdHcmlkLCBkcmF3Q3VydmUsIGRyYXdDb250cm9sUG9pbnRzIH0gZnJvbSAnLi4vbGliL2N1cnZlUmVuZGVyaW5nJ1xuaW1wb3J0IHsgZGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi4vbGliL2N1cnZlQ2FsY3VsYXRpb25zJ1xuXG5pbnRlcmZhY2UgQ3VydmVDYW52YXNQcm9wcyB7XG4gIGN1cnZlVHlwZTogQ3VydmVUeXBlXG4gIHBhcmFtZXRlcnM6IFBhcnRpYWw8Q3VydmVQYXJhbWV0ZXJzPlxuICBvblBhcmFtZXRlckNoYW5nZTogKHBhcmFtczogUGFydGlhbDxDdXJ2ZVBhcmFtZXRlcnM+KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN1cnZlQ2FudmFzKHsgY3VydmVUeXBlLCBwYXJhbWV0ZXJzLCBvblBhcmFtZXRlckNoYW5nZSB9OiBDdXJ2ZUNhbnZhc1Byb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gUmVhY3QudXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pXG4gIGNvbnN0IFtkcmFnZ2luZ1BvaW50LCBzZXREcmFnZ2luZ1BvaW50XSA9IFJlYWN0LnVzZVN0YXRlPHsgaW5kZXg6IG51bWJlcjsgcG9pbnQ6IFBvaW50IH0gfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHBhZGRpbmcgPSA2MFxuICBjb25zdCB4TWluID0gLTEwXG4gIGNvbnN0IHhNYXggPSAxMFxuICBjb25zdCB5TWluID0gLTEwXG4gIGNvbnN0IHlNYXggPSAxMFxuXG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBwYWRkaW5nLFxuICAgIHhNaW4sXG4gICAgeE1heCxcbiAgICB5TWluLFxuICAgIHlNYXgsXG4gICAgZGltZW5zaW9ucyxcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIHNldERpbWVuc2lvbnMoeyB3aWR0aCwgaGVpZ2h0IH0pXG4gICAgICAgIHNldHVwQ2FudmFzKGNhbnZhc1JlZi5jdXJyZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKVxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKVxuXG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBpZiAoY3VydmVUeXBlICE9PSAnYmV6aWVyJyB8fCAhcGFyYW1ldGVycy5iZXppZXIpIHJldHVyblxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGNvbnN0IHkgPSBpbnZlcnNlVHJhbnNmb3JtWShlLmNsaWVudFkgLSByZWN0LnRvcCwgZGltZW5zaW9ucywgY29uZmlnKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IHBvaW50SW5kZXggPSBjb250cm9sUG9pbnRzLmZpbmRJbmRleCgocG9pbnQpID0+IHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnQueCAtIHhcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnQueSAtIHlcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDwgMC41XG4gICAgfSlcblxuICAgIGlmIChwb2ludEluZGV4ICE9PSAtMSkge1xuICAgICAgc2V0RHJhZ2dpbmdQb2ludCh7IGluZGV4OiBwb2ludEluZGV4LCBwb2ludDogY29udHJvbFBvaW50c1twb2ludEluZGV4XSB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICBjb25zdCB5ID0gaW52ZXJzZVRyYW5zZm9ybVkoZS5jbGllbnRZIC0gcmVjdC50b3AsIGRpbWVuc2lvbnMsIGNvbmZpZylcblxuICAgIGNvbnN0IHsgY29udHJvbFBvaW50cyB9ID0gcGFyYW1ldGVycy5iZXppZXJcbiAgICBjb25zdCBuZXdQb2ludCA9IHsgeCwgeSB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGxpbmUgc2VnbWVudCB0byBpbnNlcnQgdGhlIG5ldyBwb2ludFxuICAgIGxldCBtaW5EaXN0ID0gSW5maW5pdHlcbiAgICBsZXQgaW5zZXJ0SW5kZXggPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBwMSA9IGNvbnRyb2xQb2ludHNbaV1cbiAgICAgIGNvbnN0IHAyID0gY29udHJvbFBvaW50c1tpICsgMV1cbiAgICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZVRvTGluZVNlZ21lbnQoeCwgeSwgcDEueCwgcDEueSwgcDIueCwgcDIueSlcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICBtaW5EaXN0ID0gZGlzdFxuICAgICAgICBpbnNlcnRJbmRleCA9IGkgKyAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gbGluZSBzZWdtZW50cyBmb3VuZCwgYXBwZW5kIHRvIHRoZSBlbmRcbiAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydEluZGV4ID0gMFxuICAgIH1cblxuICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi5jb250cm9sUG9pbnRzXVxuICAgIG5ld1BvaW50cy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5ld1BvaW50KVxuXG4gICAgb25QYXJhbWV0ZXJDaGFuZ2Uoe1xuICAgICAgYmV6aWVyOiB7XG4gICAgICAgIC4uLnBhcmFtZXRlcnMuYmV6aWVyLFxuICAgICAgICBjb250cm9sUG9pbnRzOiBuZXdQb2ludHMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBjb25zdCBoYW5kbGVDb250ZXh0TWVudSA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGlmIChjdXJ2ZVR5cGUgIT09ICdiZXppZXInIHx8ICFwYXJhbWV0ZXJzLmJlemllcikgcmV0dXJuXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICBjb25zdCB5ID0gaW52ZXJzZVRyYW5zZm9ybVkoZS5jbGllbnRZIC0gcmVjdC50b3AsIGRpbWVuc2lvbnMsIGNvbmZpZylcblxuICAgIGNvbnN0IHsgY29udHJvbFBvaW50cyB9ID0gcGFyYW1ldGVycy5iZXppZXJcbiAgICBjb25zdCBwb2ludEluZGV4ID0gY29udHJvbFBvaW50cy5maW5kSW5kZXgoKHBvaW50KSA9PiB7XG4gICAgICBjb25zdCBkeCA9IHBvaW50LnggLSB4XG4gICAgICBjb25zdCBkeSA9IHBvaW50LnkgLSB5XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSA8IDAuNVxuICAgIH0pXG5cbiAgICBpZiAocG9pbnRJbmRleCAhPT0gLTEgJiYgY29udHJvbFBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4uY29udHJvbFBvaW50c11cbiAgICAgIG5ld1BvaW50cy5zcGxpY2UocG9pbnRJbmRleCwgMSlcblxuICAgICAgb25QYXJhbWV0ZXJDaGFuZ2Uoe1xuICAgICAgICBiZXppZXI6IHtcbiAgICAgICAgICAuLi5wYXJhbWV0ZXJzLmJlemllcixcbiAgICAgICAgICBjb250cm9sUG9pbnRzOiBuZXdQb2ludHMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGlmICghZHJhZ2dpbmdQb2ludCB8fCAhcGFyYW1ldGVycy5iZXppZXIpIHJldHVyblxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGNvbnN0IHkgPSBpbnZlcnNlVHJhbnNmb3JtWShlLmNsaWVudFkgLSByZWN0LnRvcCwgZGltZW5zaW9ucywgY29uZmlnKVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnBhcmFtZXRlcnMuYmV6aWVyLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzW2RyYWdnaW5nUG9pbnQuaW5kZXhdID0geyB4LCB5IH1cblxuICAgIG9uUGFyYW1ldGVyQ2hhbmdlKHtcbiAgICAgIGJlemllcjoge1xuICAgICAgICAuLi5wYXJhbWV0ZXJzLmJlemllcixcbiAgICAgICAgY29udHJvbFBvaW50czogbmV3UG9pbnRzLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICBzZXREcmFnZ2luZ1BvaW50KG51bGwpXG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgY3R4ID0gZ2V0Q2FudmFzQ29udGV4dChjYW52YXMpXG4gICAgaWYgKCFjdHgpIHJldHVyblxuXG4gICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodClcblxuICAgIC8vIERyYXcgZ3JpZFxuICAgIGRyYXdHcmlkKGN0eCwgY29uZmlnKVxuXG4gICAgLy8gRHJhdyBjdXJ2ZVxuICAgIGRyYXdDdXJ2ZShjdHgsIGN1cnZlVHlwZSwgcGFyYW1ldGVycywgY29uZmlnKVxuXG4gICAgLy8gRHJhdyBjb250cm9sIHBvaW50cyBmb3IgQsOpemllciBjdXJ2ZXNcbiAgICBpZiAoY3VydmVUeXBlID09PSAnYmV6aWVyJyAmJiBwYXJhbWV0ZXJzLmJlemllcikge1xuICAgICAgZHJhd0NvbnRyb2xQb2ludHMoY3R4LCBwYXJhbWV0ZXJzLmJlemllci5jb250cm9sUG9pbnRzLCBjb25maWcpXG4gICAgfVxuICB9LCBbY3VydmVUeXBlLCBwYXJhbWV0ZXJzLCBkaW1lbnNpb25zXSlcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXNcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbCByb3VuZGVkLWxnIGJvcmRlciBiZy1iYWNrZ3JvdW5kXCJcbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVNb3VzZURvd259XG4gICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgb25Nb3VzZVVwPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgb25Eb3VibGVDbGljaz17aGFuZGxlRG91YmxlQ2xpY2t9XG4gICAgICBvbkNvbnRleHRNZW51PXtoYW5kbGVDb250ZXh0TWVudX1cbiAgICAvPlxuICApXG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInNldHVwQ2FudmFzIiwiZ2V0Q2FudmFzQ29udGV4dCIsImludmVyc2VUcmFuc2Zvcm1YIiwiaW52ZXJzZVRyYW5zZm9ybVkiLCJkcmF3R3JpZCIsImRyYXdDdXJ2ZSIsImRyYXdDb250cm9sUG9pbnRzIiwiZGlzdGFuY2VUb0xpbmVTZWdtZW50IiwiQ3VydmVDYW52YXMiLCJjdXJ2ZVR5cGUiLCJwYXJhbWV0ZXJzIiwib25QYXJhbWV0ZXJDaGFuZ2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsInVzZVN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkcmFnZ2luZ1BvaW50Iiwic2V0RHJhZ2dpbmdQb2ludCIsInBhZGRpbmciLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwiY29uZmlnIiwidXNlRWZmZWN0IiwidXBkYXRlRGltZW5zaW9ucyIsImN1cnJlbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZU1vdXNlRG93biIsImUiLCJiZXppZXIiLCJjYW52YXMiLCJyZWN0IiwieCIsImNsaWVudFgiLCJsZWZ0IiwieSIsImNsaWVudFkiLCJ0b3AiLCJjb250cm9sUG9pbnRzIiwicG9pbnRJbmRleCIsImZpbmRJbmRleCIsInBvaW50IiwiZHgiLCJkeSIsIk1hdGgiLCJzcXJ0IiwiaW5kZXgiLCJoYW5kbGVEb3VibGVDbGljayIsIm5ld1BvaW50IiwibWluRGlzdCIsIkluZmluaXR5IiwiaW5zZXJ0SW5kZXgiLCJpIiwibGVuZ3RoIiwicDEiLCJwMiIsImRpc3QiLCJuZXdQb2ludHMiLCJzcGxpY2UiLCJoYW5kbGVDb250ZXh0TWVudSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsImN0eCIsImNsZWFyUmVjdCIsInJlZiIsImNsYXNzTmFtZSIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwib25Db250ZXh0TWVudSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/CurveCanvas.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/canvasUtils.ts":
/*!********************************!*\
  !*** ./app/lib/canvasUtils.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCanvasContext: function() { return /* binding */ getCanvasContext; },\n/* harmony export */   inverseTransformX: function() { return /* binding */ inverseTransformX; },\n/* harmony export */   inverseTransformY: function() { return /* binding */ inverseTransformY; },\n/* harmony export */   setupCanvas: function() { return /* binding */ setupCanvas; },\n/* harmony export */   transformX: function() { return /* binding */ transformX; },\n/* harmony export */   transformY: function() { return /* binding */ transformY; }\n/* harmony export */ });\nfunction transformX(x, dimensions, config) {\n    return (x - config.xMin) / (config.xMax - config.xMin) * (dimensions.width - 2 * config.padding) + config.padding;\n}\nfunction transformY(y, dimensions, config) {\n    return dimensions.height - ((y - config.yMin) / (config.yMax - config.yMin) * (dimensions.height - 2 * config.padding) + config.padding);\n}\nfunction inverseTransformX(px, dimensions, config) {\n    return (px - config.padding) / (dimensions.width - 2 * config.padding) * (config.xMax - config.xMin) + config.xMin;\n}\nfunction inverseTransformY(py, dimensions, config) {\n    return config.yMax - (py - config.padding) / (dimensions.height - 2 * config.padding) * (config.yMax - config.yMin);\n}\nfunction setupCanvas(canvas) {\n    const { width, height } = canvas.getBoundingClientRect();\n    const scale = window.devicePixelRatio;\n    canvas.width = width * scale;\n    canvas.height = height * scale;\n}\nfunction getCanvasContext(canvas) {\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return null;\n    const scale = window.devicePixelRatio;\n    ctx.scale(scale, scale);\n    return ctx;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvY2FudmFzVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBYU8sU0FBU0EsV0FBV0MsQ0FBUyxFQUFFQyxVQUFzQixFQUFFQyxNQUF1QjtJQUNuRixPQUFPLENBQUVGLElBQUlFLE9BQU9DLElBQUksSUFBS0QsQ0FBQUEsT0FBT0UsSUFBSSxHQUFHRixPQUFPQyxJQUFJLElBQU1GLENBQUFBLFdBQVdJLEtBQUssR0FBRyxJQUFJSCxPQUFPSSxPQUFPLElBQUlKLE9BQU9JLE9BQU87QUFDckg7QUFFTyxTQUFTQyxXQUFXQyxDQUFTLEVBQUVQLFVBQXNCLEVBQUVDLE1BQXVCO0lBQ25GLE9BQU9ELFdBQVdRLE1BQU0sR0FBSSxFQUFFRCxJQUFJTixPQUFPUSxJQUFJLElBQUtSLENBQUFBLE9BQU9TLElBQUksR0FBR1QsT0FBT1EsSUFBSSxJQUFNVCxDQUFBQSxXQUFXUSxNQUFNLEdBQUcsSUFBSVAsT0FBT0ksT0FBTyxJQUFJSixPQUFPSSxPQUFPO0FBQzNJO0FBRU8sU0FBU00sa0JBQWtCQyxFQUFVLEVBQUVaLFVBQXNCLEVBQUVDLE1BQXVCO0lBQzNGLE9BQU8sQ0FBRVcsS0FBS1gsT0FBT0ksT0FBTyxJQUFLTCxDQUFBQSxXQUFXSSxLQUFLLEdBQUcsSUFBSUgsT0FBT0ksT0FBTyxJQUFNSixDQUFBQSxPQUFPRSxJQUFJLEdBQUdGLE9BQU9DLElBQUksSUFBSUQsT0FBT0MsSUFBSTtBQUN0SDtBQUVPLFNBQVNXLGtCQUFrQkMsRUFBVSxFQUFFZCxVQUFzQixFQUFFQyxNQUF1QjtJQUMzRixPQUFPQSxPQUFPUyxJQUFJLEdBQUcsQ0FBRUksS0FBS2IsT0FBT0ksT0FBTyxJQUFLTCxDQUFBQSxXQUFXUSxNQUFNLEdBQUcsSUFBSVAsT0FBT0ksT0FBTyxJQUFNSixDQUFBQSxPQUFPUyxJQUFJLEdBQUdULE9BQU9RLElBQUk7QUFDdEg7QUFFTyxTQUFTTSxZQUFZQyxNQUF5QjtJQUNuRCxNQUFNLEVBQUVaLEtBQUssRUFBRUksTUFBTSxFQUFFLEdBQUdRLE9BQU9DLHFCQUFxQjtJQUN0RCxNQUFNQyxRQUFRQyxPQUFPQyxnQkFBZ0I7SUFDckNKLE9BQU9aLEtBQUssR0FBR0EsUUFBUWM7SUFDdkJGLE9BQU9SLE1BQU0sR0FBR0EsU0FBU1U7QUFDM0I7QUFFTyxTQUFTRyxpQkFBaUJMLE1BQXlCO0lBQ3hELE1BQU1NLE1BQU1OLE9BQU9PLFVBQVUsQ0FBQztJQUM5QixJQUFJLENBQUNELEtBQUssT0FBTztJQUVqQixNQUFNSixRQUFRQyxPQUFPQyxnQkFBZ0I7SUFDckNFLElBQUlKLEtBQUssQ0FBQ0EsT0FBT0E7SUFDakIsT0FBT0k7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL2NhbnZhc1V0aWxzLnRzP2NiYTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIERpbWVuc2lvbnMge1xuICB3aWR0aDogbnVtYmVyXG4gIGhlaWdodDogbnVtYmVyXG59XG5cbmludGVyZmFjZSBUcmFuc2Zvcm1Db25maWcge1xuICBwYWRkaW5nOiBudW1iZXJcbiAgeE1pbjogbnVtYmVyXG4gIHhNYXg6IG51bWJlclxuICB5TWluOiBudW1iZXJcbiAgeU1heDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1YKHg6IG51bWJlciwgZGltZW5zaW9uczogRGltZW5zaW9ucywgY29uZmlnOiBUcmFuc2Zvcm1Db25maWcpOiBudW1iZXIge1xuICByZXR1cm4gKCh4IC0gY29uZmlnLnhNaW4pIC8gKGNvbmZpZy54TWF4IC0gY29uZmlnLnhNaW4pKSAqIChkaW1lbnNpb25zLndpZHRoIC0gMiAqIGNvbmZpZy5wYWRkaW5nKSArIGNvbmZpZy5wYWRkaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1ZKHk6IG51bWJlciwgZGltZW5zaW9uczogRGltZW5zaW9ucywgY29uZmlnOiBUcmFuc2Zvcm1Db25maWcpOiBudW1iZXIge1xuICByZXR1cm4gZGltZW5zaW9ucy5oZWlnaHQgLSAoKCh5IC0gY29uZmlnLnlNaW4pIC8gKGNvbmZpZy55TWF4IC0gY29uZmlnLnlNaW4pKSAqIChkaW1lbnNpb25zLmhlaWdodCAtIDIgKiBjb25maWcucGFkZGluZykgKyBjb25maWcucGFkZGluZylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm1YKHB4OiBudW1iZXIsIGRpbWVuc2lvbnM6IERpbWVuc2lvbnMsIGNvbmZpZzogVHJhbnNmb3JtQ29uZmlnKTogbnVtYmVyIHtcbiAgcmV0dXJuICgocHggLSBjb25maWcucGFkZGluZykgLyAoZGltZW5zaW9ucy53aWR0aCAtIDIgKiBjb25maWcucGFkZGluZykpICogKGNvbmZpZy54TWF4IC0gY29uZmlnLnhNaW4pICsgY29uZmlnLnhNaW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm1ZKHB5OiBudW1iZXIsIGRpbWVuc2lvbnM6IERpbWVuc2lvbnMsIGNvbmZpZzogVHJhbnNmb3JtQ29uZmlnKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNvbmZpZy55TWF4IC0gKChweSAtIGNvbmZpZy5wYWRkaW5nKSAvIChkaW1lbnNpb25zLmhlaWdodCAtIDIgKiBjb25maWcucGFkZGluZykpICogKGNvbmZpZy55TWF4IC0gY29uZmlnLnlNaW4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgY2FudmFzLndpZHRoID0gd2lkdGggKiBzY2FsZVxuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogc2NhbGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbnZhc0NvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICBpZiAoIWN0eCkgcmV0dXJuIG51bGxcblxuICBjb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXG4gIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpXG4gIHJldHVybiBjdHhcbn0gIl0sIm5hbWVzIjpbInRyYW5zZm9ybVgiLCJ4IiwiZGltZW5zaW9ucyIsImNvbmZpZyIsInhNaW4iLCJ4TWF4Iiwid2lkdGgiLCJwYWRkaW5nIiwidHJhbnNmb3JtWSIsInkiLCJoZWlnaHQiLCJ5TWluIiwieU1heCIsImludmVyc2VUcmFuc2Zvcm1YIiwicHgiLCJpbnZlcnNlVHJhbnNmb3JtWSIsInB5Iiwic2V0dXBDYW52YXMiLCJjYW52YXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZSIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJnZXRDYW52YXNDb250ZXh0IiwiY3R4IiwiZ2V0Q29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/canvasUtils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/curveCalculations.ts":
/*!**************************************!*\
  !*** ./app/lib/curveCalculations.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   distanceToLineSegment: function() { return /* binding */ distanceToLineSegment; },\n/* harmony export */   evaluateBezier: function() { return /* binding */ evaluateBezier; },\n/* harmony export */   evaluateParametricFunction: function() { return /* binding */ evaluateParametricFunction; },\n/* harmony export */   evaluatePolynomial: function() { return /* binding */ evaluatePolynomial; },\n/* harmony export */   getIntermediatePoints: function() { return /* binding */ getIntermediatePoints; }\n/* harmony export */ });\nfunction evaluatePolynomial(x, coefficients) {\n    return coefficients.reduce((sum, coeff, i)=>{\n        return sum + coeff * Math.pow(x, coefficients.length - 1 - i);\n    }, 0);\n}\nfunction evaluateBezier(t, points) {\n    if (points.length === 1) return points[0];\n    const newPoints = [];\n    for(let i = 0; i < points.length - 1; i++){\n        newPoints.push({\n            x: (1 - t) * points[i].x + t * points[i + 1].x,\n            y: (1 - t) * points[i].y + t * points[i + 1].y\n        });\n    }\n    return evaluateBezier(t, newPoints);\n}\nfunction getIntermediatePoints(t, points) {\n    if (points.length <= 1) return [\n        points\n    ];\n    const result = [\n        points\n    ];\n    let currentPoints = points;\n    while(currentPoints.length > 1){\n        const newPoints = [];\n        for(let i = 0; i < currentPoints.length - 1; i++){\n            newPoints.push({\n                x: (1 - t) * currentPoints[i].x + t * currentPoints[i + 1].x,\n                y: (1 - t) * currentPoints[i].y + t * currentPoints[i + 1].y\n            });\n        }\n        result.push(newPoints);\n        currentPoints = newPoints;\n    }\n    return result;\n}\nfunction distanceToLineSegment(x, y, x1, y1, x2, y2) {\n    const A = x - x1;\n    const B = y - y1;\n    const C = x2 - x1;\n    const D = y2 - y1;\n    const dot = A * C + B * D;\n    const lenSq = C * C + D * D;\n    let param = -1;\n    if (lenSq !== 0) {\n        param = dot / lenSq;\n    }\n    let xx, yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n    }\n    const dx = x - xx;\n    const dy = y - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nfunction evaluateParametricFunction(t, fn) {\n    let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    switch(fn){\n        case \"cos\":\n            return Math.cos(t) * scale;\n        case \"sin\":\n            return Math.sin(t) * scale;\n        case \"t\":\n            return t * scale;\n        case \"t^2\":\n            return t * t * scale;\n        default:\n            return 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvY3VydmVDYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFTyxTQUFTQSxtQkFBbUJDLENBQVMsRUFBRUMsWUFBc0I7SUFDbEUsT0FBT0EsYUFBYUMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE9BQU9DO1FBQ3RDLE9BQU9GLE1BQU1DLFFBQVFFLEtBQUtDLEdBQUcsQ0FBQ1AsR0FBR0MsYUFBYU8sTUFBTSxHQUFHLElBQUlIO0lBQzdELEdBQUc7QUFDTDtBQUVPLFNBQVNJLGVBQWVDLENBQVMsRUFBRUMsTUFBZTtJQUN2RCxJQUFJQSxPQUFPSCxNQUFNLEtBQUssR0FBRyxPQUFPRyxNQUFNLENBQUMsRUFBRTtJQUN6QyxNQUFNQyxZQUFxQixFQUFFO0lBQzdCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJTSxPQUFPSCxNQUFNLEdBQUcsR0FBR0gsSUFBSztRQUMxQ08sVUFBVUMsSUFBSSxDQUFDO1lBQ2JiLEdBQUcsQ0FBQyxJQUFJVSxDQUFBQSxJQUFLQyxNQUFNLENBQUNOLEVBQUUsQ0FBQ0wsQ0FBQyxHQUFHVSxJQUFJQyxNQUFNLENBQUNOLElBQUksRUFBRSxDQUFDTCxDQUFDO1lBQzlDYyxHQUFHLENBQUMsSUFBSUosQ0FBQUEsSUFBS0MsTUFBTSxDQUFDTixFQUFFLENBQUNTLENBQUMsR0FBR0osSUFBSUMsTUFBTSxDQUFDTixJQUFJLEVBQUUsQ0FBQ1MsQ0FBQztRQUNoRDtJQUNGO0lBQ0EsT0FBT0wsZUFBZUMsR0FBR0U7QUFDM0I7QUFFTyxTQUFTRyxzQkFBc0JMLENBQVMsRUFBRUMsTUFBZTtJQUM5RCxJQUFJQSxPQUFPSCxNQUFNLElBQUksR0FBRyxPQUFPO1FBQUNHO0tBQU87SUFFdkMsTUFBTUssU0FBb0I7UUFBQ0w7S0FBTztJQUNsQyxJQUFJTSxnQkFBZ0JOO0lBRXBCLE1BQU9NLGNBQWNULE1BQU0sR0FBRyxFQUFHO1FBQy9CLE1BQU1JLFlBQXFCLEVBQUU7UUFDN0IsSUFBSyxJQUFJUCxJQUFJLEdBQUdBLElBQUlZLGNBQWNULE1BQU0sR0FBRyxHQUFHSCxJQUFLO1lBQ2pETyxVQUFVQyxJQUFJLENBQUM7Z0JBQ2JiLEdBQUcsQ0FBQyxJQUFJVSxDQUFBQSxJQUFLTyxhQUFhLENBQUNaLEVBQUUsQ0FBQ0wsQ0FBQyxHQUFHVSxJQUFJTyxhQUFhLENBQUNaLElBQUksRUFBRSxDQUFDTCxDQUFDO2dCQUM1RGMsR0FBRyxDQUFDLElBQUlKLENBQUFBLElBQUtPLGFBQWEsQ0FBQ1osRUFBRSxDQUFDUyxDQUFDLEdBQUdKLElBQUlPLGFBQWEsQ0FBQ1osSUFBSSxFQUFFLENBQUNTLENBQUM7WUFDOUQ7UUFDRjtRQUNBRSxPQUFPSCxJQUFJLENBQUNEO1FBQ1pLLGdCQUFnQkw7SUFDbEI7SUFFQSxPQUFPSTtBQUNUO0FBRU8sU0FBU0Usc0JBQXNCbEIsQ0FBUyxFQUFFYyxDQUFTLEVBQUVLLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLEVBQVU7SUFDeEcsTUFBTUMsSUFBSXZCLElBQUltQjtJQUNkLE1BQU1LLElBQUlWLElBQUlNO0lBQ2QsTUFBTUssSUFBSUosS0FBS0Y7SUFDZixNQUFNTyxJQUFJSixLQUFLRjtJQUVmLE1BQU1PLE1BQU1KLElBQUlFLElBQUlELElBQUlFO0lBQ3hCLE1BQU1FLFFBQVFILElBQUlBLElBQUlDLElBQUlBO0lBQzFCLElBQUlHLFFBQVEsQ0FBQztJQUViLElBQUlELFVBQVUsR0FBRztRQUNmQyxRQUFRRixNQUFNQztJQUNoQjtJQUVBLElBQUlFLElBQUlDO0lBRVIsSUFBSUYsUUFBUSxHQUFHO1FBQ2JDLEtBQUtYO1FBQ0xZLEtBQUtYO0lBQ1AsT0FBTyxJQUFJUyxRQUFRLEdBQUc7UUFDcEJDLEtBQUtUO1FBQ0xVLEtBQUtUO0lBQ1AsT0FBTztRQUNMUSxLQUFLWCxLQUFLVSxRQUFRSjtRQUNsQk0sS0FBS1gsS0FBS1MsUUFBUUg7SUFDcEI7SUFFQSxNQUFNTSxLQUFLaEMsSUFBSThCO0lBQ2YsTUFBTUcsS0FBS25CLElBQUlpQjtJQUVmLE9BQU96QixLQUFLNEIsSUFBSSxDQUFDRixLQUFLQSxLQUFLQyxLQUFLQTtBQUNsQztBQUVPLFNBQVNFLDJCQUEyQnpCLENBQVMsRUFBRTBCLEVBQVU7UUFBRUMsUUFBQUEsaUVBQWdCO0lBQ2hGLE9BQVFEO1FBQ04sS0FBSztZQUNILE9BQU85QixLQUFLZ0MsR0FBRyxDQUFDNUIsS0FBSzJCO1FBQ3ZCLEtBQUs7WUFDSCxPQUFPL0IsS0FBS2lDLEdBQUcsQ0FBQzdCLEtBQUsyQjtRQUN2QixLQUFLO1lBQ0gsT0FBTzNCLElBQUkyQjtRQUNiLEtBQUs7WUFDSCxPQUFPM0IsSUFBSUEsSUFBSTJCO1FBQ2pCO1lBQ0UsT0FBTztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xpYi9jdXJ2ZUNhbGN1bGF0aW9ucy50cz9kYmZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vdHlwZXMvY3VydmVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVQb2x5bm9taWFsKHg6IG51bWJlciwgY29lZmZpY2llbnRzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIHJldHVybiBjb2VmZmljaWVudHMucmVkdWNlKChzdW0sIGNvZWZmLCBpKSA9PiB7XG4gICAgcmV0dXJuIHN1bSArIGNvZWZmICogTWF0aC5wb3coeCwgY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBpKVxuICB9LCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVCZXppZXIodDogbnVtYmVyLCBwb2ludHM6IFBvaW50W10pOiBQb2ludCB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSByZXR1cm4gcG9pbnRzWzBdXG4gIGNvbnN0IG5ld1BvaW50czogUG9pbnRbXSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIG5ld1BvaW50cy5wdXNoKHtcbiAgICAgIHg6ICgxIC0gdCkgKiBwb2ludHNbaV0ueCArIHQgKiBwb2ludHNbaSArIDFdLngsXG4gICAgICB5OiAoMSAtIHQpICogcG9pbnRzW2ldLnkgKyB0ICogcG9pbnRzW2kgKyAxXS55LFxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlQmV6aWVyKHQsIG5ld1BvaW50cylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybWVkaWF0ZVBvaW50cyh0OiBudW1iZXIsIHBvaW50czogUG9pbnRbXSk6IFBvaW50W11bXSB7XG4gIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpIHJldHVybiBbcG9pbnRzXVxuICBcbiAgY29uc3QgcmVzdWx0OiBQb2ludFtdW10gPSBbcG9pbnRzXVxuICBsZXQgY3VycmVudFBvaW50cyA9IHBvaW50c1xuICBcbiAgd2hpbGUgKGN1cnJlbnRQb2ludHMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5ld1BvaW50czogUG9pbnRbXSA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50UG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgbmV3UG9pbnRzLnB1c2goe1xuICAgICAgICB4OiAoMSAtIHQpICogY3VycmVudFBvaW50c1tpXS54ICsgdCAqIGN1cnJlbnRQb2ludHNbaSArIDFdLngsXG4gICAgICAgIHk6ICgxIC0gdCkgKiBjdXJyZW50UG9pbnRzW2ldLnkgKyB0ICogY3VycmVudFBvaW50c1tpICsgMV0ueSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG5ld1BvaW50cylcbiAgICBjdXJyZW50UG9pbnRzID0gbmV3UG9pbnRzXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlVG9MaW5lU2VnbWVudCh4OiBudW1iZXIsIHk6IG51bWJlciwgeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IEEgPSB4IC0geDFcbiAgY29uc3QgQiA9IHkgLSB5MVxuICBjb25zdCBDID0geDIgLSB4MVxuICBjb25zdCBEID0geTIgLSB5MVxuXG4gIGNvbnN0IGRvdCA9IEEgKiBDICsgQiAqIERcbiAgY29uc3QgbGVuU3EgPSBDICogQyArIEQgKiBEXG4gIGxldCBwYXJhbSA9IC0xXG5cbiAgaWYgKGxlblNxICE9PSAwKSB7XG4gICAgcGFyYW0gPSBkb3QgLyBsZW5TcVxuICB9XG5cbiAgbGV0IHh4LCB5eVxuXG4gIGlmIChwYXJhbSA8IDApIHtcbiAgICB4eCA9IHgxXG4gICAgeXkgPSB5MVxuICB9IGVsc2UgaWYgKHBhcmFtID4gMSkge1xuICAgIHh4ID0geDJcbiAgICB5eSA9IHkyXG4gIH0gZWxzZSB7XG4gICAgeHggPSB4MSArIHBhcmFtICogQ1xuICAgIHl5ID0geTEgKyBwYXJhbSAqIERcbiAgfVxuXG4gIGNvbnN0IGR4ID0geCAtIHh4XG4gIGNvbnN0IGR5ID0geSAtIHl5XG5cbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlUGFyYW1ldHJpY0Z1bmN0aW9uKHQ6IG51bWJlciwgZm46IHN0cmluZywgc2NhbGU6IG51bWJlciA9IDEpOiBudW1iZXIge1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnY29zJzpcbiAgICAgIHJldHVybiBNYXRoLmNvcyh0KSAqIHNjYWxlXG4gICAgY2FzZSAnc2luJzpcbiAgICAgIHJldHVybiBNYXRoLnNpbih0KSAqIHNjYWxlXG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdCAqIHNjYWxlXG4gICAgY2FzZSAndF4yJzpcbiAgICAgIHJldHVybiB0ICogdCAqIHNjYWxlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwXG4gIH1cbn0gIl0sIm5hbWVzIjpbImV2YWx1YXRlUG9seW5vbWlhbCIsIngiLCJjb2VmZmljaWVudHMiLCJyZWR1Y2UiLCJzdW0iLCJjb2VmZiIsImkiLCJNYXRoIiwicG93IiwibGVuZ3RoIiwiZXZhbHVhdGVCZXppZXIiLCJ0IiwicG9pbnRzIiwibmV3UG9pbnRzIiwicHVzaCIsInkiLCJnZXRJbnRlcm1lZGlhdGVQb2ludHMiLCJyZXN1bHQiLCJjdXJyZW50UG9pbnRzIiwiZGlzdGFuY2VUb0xpbmVTZWdtZW50IiwieDEiLCJ5MSIsIngyIiwieTIiLCJBIiwiQiIsIkMiLCJEIiwiZG90IiwibGVuU3EiLCJwYXJhbSIsInh4IiwieXkiLCJkeCIsImR5Iiwic3FydCIsImV2YWx1YXRlUGFyYW1ldHJpY0Z1bmN0aW9uIiwiZm4iLCJzY2FsZSIsImNvcyIsInNpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/curveCalculations.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/lib/curveRendering.ts":
/*!***********************************!*\
  !*** ./app/lib/curveRendering.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawControlPoints: function() { return /* binding */ drawControlPoints; },\n/* harmony export */   drawCurve: function() { return /* binding */ drawCurve; },\n/* harmony export */   drawGrid: function() { return /* binding */ drawGrid; }\n/* harmony export */ });\n/* harmony import */ var _curveCalculations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curveCalculations */ \"(app-pages-browser)/./app/lib/curveCalculations.ts\");\n/* harmony import */ var _canvasUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvasUtils */ \"(app-pages-browser)/./app/lib/canvasUtils.ts\");\n\n\nfunction drawGrid(ctx, config) {\n    const { padding, xMin, xMax, yMin, yMax, dimensions } = config;\n    const { width, height } = dimensions;\n    ctx.strokeStyle = \"#e5e7eb\";\n    ctx.lineWidth = 1;\n    // Draw vertical grid lines\n    for(let x = Math.ceil(xMin); x <= xMax; x++){\n        const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(x, dimensions, config);\n        ctx.beginPath();\n        ctx.moveTo(px, padding);\n        ctx.lineTo(px, height - padding);\n        ctx.stroke();\n        // Draw x-axis labels\n        ctx.fillStyle = \"#6b7280\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(x.toString(), px, height - padding + 20);\n    }\n    // Draw horizontal grid lines\n    for(let y = Math.ceil(yMin); y <= yMax; y++){\n        const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(y, dimensions, config);\n        ctx.beginPath();\n        ctx.moveTo(padding, py);\n        ctx.lineTo(width - padding, py);\n        ctx.stroke();\n        // Draw y-axis labels\n        ctx.fillStyle = \"#6b7280\";\n        ctx.textAlign = \"right\";\n        ctx.fillText(y.toString(), padding - 10, py);\n    }\n    // Draw axes\n    ctx.strokeStyle = \"#374151\";\n    ctx.lineWidth = 2;\n    // X-axis\n    const yAxis = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(0, dimensions, config);\n    ctx.beginPath();\n    ctx.moveTo(padding, yAxis);\n    ctx.lineTo(width - padding, yAxis);\n    ctx.stroke();\n    // Y-axis\n    const xAxis = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(0, dimensions, config);\n    ctx.beginPath();\n    ctx.moveTo(xAxis, padding);\n    ctx.lineTo(xAxis, height - padding);\n    ctx.stroke();\n}\nfunction drawCurve(ctx, curveType, parameters, config) {\n    const { padding, xMin, xMax, yMin, yMax, dimensions } = config;\n    const { width, height } = dimensions;\n    ctx.strokeStyle = \"#3b82f6\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    switch(curveType){\n        case \"polynomial\":\n            {\n                if (!parameters.polynomial) return;\n                const { coefficients } = parameters.polynomial;\n                let first = true;\n                for(let x = xMin; x <= xMax; x += 0.01){\n                    const y = (0,_curveCalculations__WEBPACK_IMPORTED_MODULE_0__.evaluatePolynomial)(x, coefficients);\n                    const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(x, dimensions, config);\n                    const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(y, dimensions, config);\n                    if (first) {\n                        ctx.moveTo(px, py);\n                        first = false;\n                    } else {\n                        ctx.lineTo(px, py);\n                    }\n                }\n                break;\n            }\n        case \"bezier\":\n            {\n                if (!parameters.bezier) return;\n                const { controlPoints } = parameters.bezier;\n                let first = true;\n                for(let t = 0; t <= 1; t += 0.01){\n                    const point = (0,_curveCalculations__WEBPACK_IMPORTED_MODULE_0__.evaluateBezier)(t, controlPoints);\n                    const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(point.x, dimensions, config);\n                    const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(point.y, dimensions, config);\n                    if (first) {\n                        ctx.moveTo(px, py);\n                        first = false;\n                    } else {\n                        ctx.lineTo(px, py);\n                    }\n                }\n                break;\n            }\n        case \"parametric\":\n            {\n                if (!parameters.parametric) return;\n                const { tMin, tMax, xFunction, yFunction, xScale, yScale } = parameters.parametric;\n                let first = true;\n                for(let t = tMin; t <= tMax; t += 0.01){\n                    const x = (0,_curveCalculations__WEBPACK_IMPORTED_MODULE_0__.evaluateParametricFunction)(t, xFunction, xScale);\n                    const y = (0,_curveCalculations__WEBPACK_IMPORTED_MODULE_0__.evaluateParametricFunction)(t, yFunction, yScale);\n                    const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(x, dimensions, config);\n                    const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(y, dimensions, config);\n                    if (first) {\n                        ctx.moveTo(px, py);\n                        first = false;\n                    } else {\n                        ctx.lineTo(px, py);\n                    }\n                }\n                break;\n            }\n        case \"trigonometric\":\n            {\n                if (!parameters.trigonometric) return;\n                const { amplitude, frequency, phase } = parameters.trigonometric;\n                let first = true;\n                for(let x = xMin; x <= xMax; x += 0.01){\n                    const y = amplitude * Math.sin(frequency * x + phase);\n                    const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(x, dimensions, config);\n                    const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(y, dimensions, config);\n                    if (first) {\n                        ctx.moveTo(px, py);\n                        first = false;\n                    } else {\n                        ctx.lineTo(px, py);\n                    }\n                }\n                break;\n            }\n        case \"exponential\":\n            {\n                if (!parameters.exponential) return;\n                const { base, coefficient, verticalShift } = parameters.exponential;\n                let first = true;\n                for(let x = xMin; x <= xMax; x += 0.01){\n                    const y = coefficient * Math.pow(base, x) + verticalShift;\n                    const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(x, dimensions, config);\n                    const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(y, dimensions, config);\n                    if (first) {\n                        ctx.moveTo(px, py);\n                        first = false;\n                    } else {\n                        ctx.lineTo(px, py);\n                    }\n                }\n                break;\n            }\n    }\n    ctx.stroke();\n}\nfunction drawControlPoints(ctx, points, config) {\n    ctx.fillStyle = \"#3b82f6\";\n    ctx.strokeStyle = \"#2563eb\";\n    ctx.lineWidth = 2;\n    // Draw control points\n    points.forEach((point)=>{\n        const px = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(point.x, config.dimensions, config);\n        const py = (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(point.y, config.dimensions, config);\n        ctx.beginPath();\n        ctx.arc(px, py, 4, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.stroke();\n    });\n    // Draw control lines\n    ctx.strokeStyle = \"#93c5fd\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo((0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(points[0].x, config.dimensions, config), (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(points[0].y, config.dimensions, config));\n    for(let i = 1; i < points.length; i++){\n        ctx.lineTo((0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformX)(points[i].x, config.dimensions, config), (0,_canvasUtils__WEBPACK_IMPORTED_MODULE_1__.transformY)(points[i].y, config.dimensions, config));\n    }\n    ctx.stroke();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9saWIvY3VydmVSZW5kZXJpbmcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDb0c7QUFDZjtBQVc5RSxTQUFTSyxTQUFTQyxHQUE2QixFQUFFQyxNQUFvQjtJQUMxRSxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxVQUFVLEVBQUUsR0FBR047SUFDeEQsTUFBTSxFQUFFTyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUUxQlAsSUFBSVUsV0FBVyxHQUFHO0lBQ2xCVixJQUFJVyxTQUFTLEdBQUc7SUFFaEIsMkJBQTJCO0lBQzNCLElBQUssSUFBSUMsSUFBSUMsS0FBS0MsSUFBSSxDQUFDWCxPQUFPUyxLQUFLUixNQUFNUSxJQUFLO1FBQzVDLE1BQU1HLEtBQUtsQix3REFBVUEsQ0FBQ2UsR0FBR0wsWUFBWU47UUFDckNELElBQUlnQixTQUFTO1FBQ2JoQixJQUFJaUIsTUFBTSxDQUFDRixJQUFJYjtRQUNmRixJQUFJa0IsTUFBTSxDQUFDSCxJQUFJTixTQUFTUDtRQUN4QkYsSUFBSW1CLE1BQU07UUFFVixxQkFBcUI7UUFDckJuQixJQUFJb0IsU0FBUyxHQUFHO1FBQ2hCcEIsSUFBSXFCLFNBQVMsR0FBRztRQUNoQnJCLElBQUlzQixRQUFRLENBQUNWLEVBQUVXLFFBQVEsSUFBSVIsSUFBSU4sU0FBU1AsVUFBVTtJQUNwRDtJQUVBLDZCQUE2QjtJQUM3QixJQUFLLElBQUlzQixJQUFJWCxLQUFLQyxJQUFJLENBQUNULE9BQU9tQixLQUFLbEIsTUFBTWtCLElBQUs7UUFDNUMsTUFBTUMsS0FBSzNCLHdEQUFVQSxDQUFDMEIsR0FBR2pCLFlBQVlOO1FBQ3JDRCxJQUFJZ0IsU0FBUztRQUNiaEIsSUFBSWlCLE1BQU0sQ0FBQ2YsU0FBU3VCO1FBQ3BCekIsSUFBSWtCLE1BQU0sQ0FBQ1YsUUFBUU4sU0FBU3VCO1FBQzVCekIsSUFBSW1CLE1BQU07UUFFVixxQkFBcUI7UUFDckJuQixJQUFJb0IsU0FBUyxHQUFHO1FBQ2hCcEIsSUFBSXFCLFNBQVMsR0FBRztRQUNoQnJCLElBQUlzQixRQUFRLENBQUNFLEVBQUVELFFBQVEsSUFBSXJCLFVBQVUsSUFBSXVCO0lBQzNDO0lBRUEsWUFBWTtJQUNaekIsSUFBSVUsV0FBVyxHQUFHO0lBQ2xCVixJQUFJVyxTQUFTLEdBQUc7SUFFaEIsU0FBUztJQUNULE1BQU1lLFFBQVE1Qix3REFBVUEsQ0FBQyxHQUFHUyxZQUFZTjtJQUN4Q0QsSUFBSWdCLFNBQVM7SUFDYmhCLElBQUlpQixNQUFNLENBQUNmLFNBQVN3QjtJQUNwQjFCLElBQUlrQixNQUFNLENBQUNWLFFBQVFOLFNBQVN3QjtJQUM1QjFCLElBQUltQixNQUFNO0lBRVYsU0FBUztJQUNULE1BQU1RLFFBQVE5Qix3REFBVUEsQ0FBQyxHQUFHVSxZQUFZTjtJQUN4Q0QsSUFBSWdCLFNBQVM7SUFDYmhCLElBQUlpQixNQUFNLENBQUNVLE9BQU96QjtJQUNsQkYsSUFBSWtCLE1BQU0sQ0FBQ1MsT0FBT2xCLFNBQVNQO0lBQzNCRixJQUFJbUIsTUFBTTtBQUNaO0FBRU8sU0FBU1MsVUFDZDVCLEdBQTZCLEVBQzdCNkIsU0FBb0IsRUFDcEJDLFVBQW9DLEVBQ3BDN0IsTUFBb0I7SUFFcEIsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFLEdBQUdOO0lBQ3hELE1BQU0sRUFBRU8sS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR0Y7SUFFMUJQLElBQUlVLFdBQVcsR0FBRztJQUNsQlYsSUFBSVcsU0FBUyxHQUFHO0lBQ2hCWCxJQUFJZ0IsU0FBUztJQUViLE9BQVFhO1FBQ04sS0FBSztZQUFjO2dCQUNqQixJQUFJLENBQUNDLFdBQVdDLFVBQVUsRUFBRTtnQkFDNUIsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0YsV0FBV0MsVUFBVTtnQkFDOUMsSUFBSUUsUUFBUTtnQkFDWixJQUFLLElBQUlyQixJQUFJVCxNQUFNUyxLQUFLUixNQUFNUSxLQUFLLEtBQU07b0JBQ3ZDLE1BQU1ZLElBQUk5QixzRUFBa0JBLENBQUNrQixHQUFHb0I7b0JBQ2hDLE1BQU1qQixLQUFLbEIsd0RBQVVBLENBQUNlLEdBQUdMLFlBQVlOO29CQUNyQyxNQUFNd0IsS0FBSzNCLHdEQUFVQSxDQUFDMEIsR0FBR2pCLFlBQVlOO29CQUNyQyxJQUFJZ0MsT0FBTzt3QkFDVGpDLElBQUlpQixNQUFNLENBQUNGLElBQUlVO3dCQUNmUSxRQUFRO29CQUNWLE9BQU87d0JBQ0xqQyxJQUFJa0IsTUFBTSxDQUFDSCxJQUFJVTtvQkFDakI7Z0JBQ0Y7Z0JBQ0E7WUFDRjtRQUVBLEtBQUs7WUFBVTtnQkFDYixJQUFJLENBQUNLLFdBQVdJLE1BQU0sRUFBRTtnQkFDeEIsTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBR0wsV0FBV0ksTUFBTTtnQkFDM0MsSUFBSUQsUUFBUTtnQkFDWixJQUFLLElBQUlHLElBQUksR0FBR0EsS0FBSyxHQUFHQSxLQUFLLEtBQU07b0JBQ2pDLE1BQU1DLFFBQVExQyxrRUFBY0EsQ0FBQ3lDLEdBQUdEO29CQUNoQyxNQUFNcEIsS0FBS2xCLHdEQUFVQSxDQUFDd0MsTUFBTXpCLENBQUMsRUFBRUwsWUFBWU47b0JBQzNDLE1BQU13QixLQUFLM0Isd0RBQVVBLENBQUN1QyxNQUFNYixDQUFDLEVBQUVqQixZQUFZTjtvQkFDM0MsSUFBSWdDLE9BQU87d0JBQ1RqQyxJQUFJaUIsTUFBTSxDQUFDRixJQUFJVTt3QkFDZlEsUUFBUTtvQkFDVixPQUFPO3dCQUNMakMsSUFBSWtCLE1BQU0sQ0FBQ0gsSUFBSVU7b0JBQ2pCO2dCQUNGO2dCQUNBO1lBQ0Y7UUFFQSxLQUFLO1lBQWM7Z0JBQ2pCLElBQUksQ0FBQ0ssV0FBV1EsVUFBVSxFQUFFO2dCQUM1QixNQUFNLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR2QsV0FBV1EsVUFBVTtnQkFDbEYsSUFBSUwsUUFBUTtnQkFDWixJQUFLLElBQUlHLElBQUlHLE1BQU1ILEtBQUtJLE1BQU1KLEtBQUssS0FBTTtvQkFDdkMsTUFBTXhCLElBQUloQiw4RUFBMEJBLENBQUN3QyxHQUFHSyxXQUFXRTtvQkFDbkQsTUFBTW5CLElBQUk1Qiw4RUFBMEJBLENBQUN3QyxHQUFHTSxXQUFXRTtvQkFDbkQsTUFBTTdCLEtBQUtsQix3REFBVUEsQ0FBQ2UsR0FBR0wsWUFBWU47b0JBQ3JDLE1BQU13QixLQUFLM0Isd0RBQVVBLENBQUMwQixHQUFHakIsWUFBWU47b0JBQ3JDLElBQUlnQyxPQUFPO3dCQUNUakMsSUFBSWlCLE1BQU0sQ0FBQ0YsSUFBSVU7d0JBQ2ZRLFFBQVE7b0JBQ1YsT0FBTzt3QkFDTGpDLElBQUlrQixNQUFNLENBQUNILElBQUlVO29CQUNqQjtnQkFDRjtnQkFDQTtZQUNGO1FBRUEsS0FBSztZQUFpQjtnQkFDcEIsSUFBSSxDQUFDSyxXQUFXZSxhQUFhLEVBQUU7Z0JBQy9CLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRSxHQUFHbEIsV0FBV2UsYUFBYTtnQkFDaEUsSUFBSVosUUFBUTtnQkFDWixJQUFLLElBQUlyQixJQUFJVCxNQUFNUyxLQUFLUixNQUFNUSxLQUFLLEtBQU07b0JBQ3ZDLE1BQU1ZLElBQUlzQixZQUFZakMsS0FBS29DLEdBQUcsQ0FBQ0YsWUFBWW5DLElBQUlvQztvQkFDL0MsTUFBTWpDLEtBQUtsQix3REFBVUEsQ0FBQ2UsR0FBR0wsWUFBWU47b0JBQ3JDLE1BQU13QixLQUFLM0Isd0RBQVVBLENBQUMwQixHQUFHakIsWUFBWU47b0JBQ3JDLElBQUlnQyxPQUFPO3dCQUNUakMsSUFBSWlCLE1BQU0sQ0FBQ0YsSUFBSVU7d0JBQ2ZRLFFBQVE7b0JBQ1YsT0FBTzt3QkFDTGpDLElBQUlrQixNQUFNLENBQUNILElBQUlVO29CQUNqQjtnQkFDRjtnQkFDQTtZQUNGO1FBRUEsS0FBSztZQUFlO2dCQUNsQixJQUFJLENBQUNLLFdBQVdvQixXQUFXLEVBQUU7Z0JBQzdCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLGFBQWEsRUFBRSxHQUFHdkIsV0FBV29CLFdBQVc7Z0JBQ25FLElBQUlqQixRQUFRO2dCQUNaLElBQUssSUFBSXJCLElBQUlULE1BQU1TLEtBQUtSLE1BQU1RLEtBQUssS0FBTTtvQkFDdkMsTUFBTVksSUFBSTRCLGNBQWN2QyxLQUFLeUMsR0FBRyxDQUFDSCxNQUFNdkMsS0FBS3lDO29CQUM1QyxNQUFNdEMsS0FBS2xCLHdEQUFVQSxDQUFDZSxHQUFHTCxZQUFZTjtvQkFDckMsTUFBTXdCLEtBQUszQix3REFBVUEsQ0FBQzBCLEdBQUdqQixZQUFZTjtvQkFDckMsSUFBSWdDLE9BQU87d0JBQ1RqQyxJQUFJaUIsTUFBTSxDQUFDRixJQUFJVTt3QkFDZlEsUUFBUTtvQkFDVixPQUFPO3dCQUNMakMsSUFBSWtCLE1BQU0sQ0FBQ0gsSUFBSVU7b0JBQ2pCO2dCQUNGO2dCQUNBO1lBQ0Y7SUFDRjtJQUVBekIsSUFBSW1CLE1BQU07QUFDWjtBQUVPLFNBQVNvQyxrQkFDZHZELEdBQTZCLEVBQzdCd0QsTUFBZSxFQUNmdkQsTUFBb0I7SUFFcEJELElBQUlvQixTQUFTLEdBQUc7SUFDaEJwQixJQUFJVSxXQUFXLEdBQUc7SUFDbEJWLElBQUlXLFNBQVMsR0FBRztJQUVoQixzQkFBc0I7SUFDdEI2QyxPQUFPQyxPQUFPLENBQUMsQ0FBQ3BCO1FBQ2QsTUFBTXRCLEtBQUtsQix3REFBVUEsQ0FBQ3dDLE1BQU16QixDQUFDLEVBQUVYLE9BQU9NLFVBQVUsRUFBRU47UUFDbEQsTUFBTXdCLEtBQUszQix3REFBVUEsQ0FBQ3VDLE1BQU1iLENBQUMsRUFBRXZCLE9BQU9NLFVBQVUsRUFBRU47UUFDbERELElBQUlnQixTQUFTO1FBQ2JoQixJQUFJMEQsR0FBRyxDQUFDM0MsSUFBSVUsSUFBSSxHQUFHLEdBQUcsSUFBSVosS0FBSzhDLEVBQUU7UUFDakMzRCxJQUFJNEQsSUFBSTtRQUNSNUQsSUFBSW1CLE1BQU07SUFDWjtJQUVBLHFCQUFxQjtJQUNyQm5CLElBQUlVLFdBQVcsR0FBRztJQUNsQlYsSUFBSVcsU0FBUyxHQUFHO0lBQ2hCWCxJQUFJZ0IsU0FBUztJQUNiaEIsSUFBSWlCLE1BQU0sQ0FDUnBCLHdEQUFVQSxDQUFDMkQsTUFBTSxDQUFDLEVBQUUsQ0FBQzVDLENBQUMsRUFBRVgsT0FBT00sVUFBVSxFQUFFTixTQUMzQ0gsd0RBQVVBLENBQUMwRCxNQUFNLENBQUMsRUFBRSxDQUFDaEMsQ0FBQyxFQUFFdkIsT0FBT00sVUFBVSxFQUFFTjtJQUU3QyxJQUFLLElBQUk0RCxJQUFJLEdBQUdBLElBQUlMLE9BQU9NLE1BQU0sRUFBRUQsSUFBSztRQUN0QzdELElBQUlrQixNQUFNLENBQ1JyQix3REFBVUEsQ0FBQzJELE1BQU0sQ0FBQ0ssRUFBRSxDQUFDakQsQ0FBQyxFQUFFWCxPQUFPTSxVQUFVLEVBQUVOLFNBQzNDSCx3REFBVUEsQ0FBQzBELE1BQU0sQ0FBQ0ssRUFBRSxDQUFDckMsQ0FBQyxFQUFFdkIsT0FBT00sVUFBVSxFQUFFTjtJQUUvQztJQUNBRCxJQUFJbUIsTUFBTTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvY3VydmVSZW5kZXJpbmcudHM/MTQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDdXJ2ZVBhcmFtZXRlcnMsIEN1cnZlVHlwZSwgUG9pbnQgfSBmcm9tICcuLi90eXBlcy9jdXJ2ZXMnXG5pbXBvcnQgeyBldmFsdWF0ZVBvbHlub21pYWwsIGV2YWx1YXRlQmV6aWVyLCBldmFsdWF0ZVBhcmFtZXRyaWNGdW5jdGlvbiB9IGZyb20gJy4vY3VydmVDYWxjdWxhdGlvbnMnXG5pbXBvcnQgeyB0cmFuc2Zvcm1YLCB0cmFuc2Zvcm1ZLCBzZXR1cENhbnZhcywgZ2V0Q2FudmFzQ29udGV4dCB9IGZyb20gJy4vY2FudmFzVXRpbHMnXG5cbmludGVyZmFjZSBSZW5kZXJDb25maWcge1xuICBwYWRkaW5nOiBudW1iZXJcbiAgeE1pbjogbnVtYmVyXG4gIHhNYXg6IG51bWJlclxuICB5TWluOiBudW1iZXJcbiAgeU1heDogbnVtYmVyXG4gIGRpbWVuc2lvbnM6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0dyaWQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNvbmZpZzogUmVuZGVyQ29uZmlnKSB7XG4gIGNvbnN0IHsgcGFkZGluZywgeE1pbiwgeE1heCwgeU1pbiwgeU1heCwgZGltZW5zaW9ucyB9ID0gY29uZmlnXG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZGltZW5zaW9uc1xuXG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjZTVlN2ViJ1xuICBjdHgubGluZVdpZHRoID0gMVxuXG4gIC8vIERyYXcgdmVydGljYWwgZ3JpZCBsaW5lc1xuICBmb3IgKGxldCB4ID0gTWF0aC5jZWlsKHhNaW4pOyB4IDw9IHhNYXg7IHgrKykge1xuICAgIGNvbnN0IHB4ID0gdHJhbnNmb3JtWCh4LCBkaW1lbnNpb25zLCBjb25maWcpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbyhweCwgcGFkZGluZylcbiAgICBjdHgubGluZVRvKHB4LCBoZWlnaHQgLSBwYWRkaW5nKVxuICAgIGN0eC5zdHJva2UoKVxuXG4gICAgLy8gRHJhdyB4LWF4aXMgbGFiZWxzXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjNmI3MjgwJ1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJ1xuICAgIGN0eC5maWxsVGV4dCh4LnRvU3RyaW5nKCksIHB4LCBoZWlnaHQgLSBwYWRkaW5nICsgMjApXG4gIH1cblxuICAvLyBEcmF3IGhvcml6b250YWwgZ3JpZCBsaW5lc1xuICBmb3IgKGxldCB5ID0gTWF0aC5jZWlsKHlNaW4pOyB5IDw9IHlNYXg7IHkrKykge1xuICAgIGNvbnN0IHB5ID0gdHJhbnNmb3JtWSh5LCBkaW1lbnNpb25zLCBjb25maWcpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbyhwYWRkaW5nLCBweSlcbiAgICBjdHgubGluZVRvKHdpZHRoIC0gcGFkZGluZywgcHkpXG4gICAgY3R4LnN0cm9rZSgpXG5cbiAgICAvLyBEcmF3IHktYXhpcyBsYWJlbHNcbiAgICBjdHguZmlsbFN0eWxlID0gJyM2YjcyODAnXG4gICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCdcbiAgICBjdHguZmlsbFRleHQoeS50b1N0cmluZygpLCBwYWRkaW5nIC0gMTAsIHB5KVxuICB9XG5cbiAgLy8gRHJhdyBheGVzXG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjMzc0MTUxJ1xuICBjdHgubGluZVdpZHRoID0gMlxuXG4gIC8vIFgtYXhpc1xuICBjb25zdCB5QXhpcyA9IHRyYW5zZm9ybVkoMCwgZGltZW5zaW9ucywgY29uZmlnKVxuICBjdHguYmVnaW5QYXRoKClcbiAgY3R4Lm1vdmVUbyhwYWRkaW5nLCB5QXhpcylcbiAgY3R4LmxpbmVUbyh3aWR0aCAtIHBhZGRpbmcsIHlBeGlzKVxuICBjdHguc3Ryb2tlKClcblxuICAvLyBZLWF4aXNcbiAgY29uc3QgeEF4aXMgPSB0cmFuc2Zvcm1YKDAsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgY3R4LmJlZ2luUGF0aCgpXG4gIGN0eC5tb3ZlVG8oeEF4aXMsIHBhZGRpbmcpXG4gIGN0eC5saW5lVG8oeEF4aXMsIGhlaWdodCAtIHBhZGRpbmcpXG4gIGN0eC5zdHJva2UoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0N1cnZlKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgY3VydmVUeXBlOiBDdXJ2ZVR5cGUsXG4gIHBhcmFtZXRlcnM6IFBhcnRpYWw8Q3VydmVQYXJhbWV0ZXJzPixcbiAgY29uZmlnOiBSZW5kZXJDb25maWdcbikge1xuICBjb25zdCB7IHBhZGRpbmcsIHhNaW4sIHhNYXgsIHlNaW4sIHlNYXgsIGRpbWVuc2lvbnMgfSA9IGNvbmZpZ1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbWVuc2lvbnNcblxuICBjdHguc3Ryb2tlU3R5bGUgPSAnIzNiODJmNidcbiAgY3R4LmxpbmVXaWR0aCA9IDJcbiAgY3R4LmJlZ2luUGF0aCgpXG5cbiAgc3dpdGNoIChjdXJ2ZVR5cGUpIHtcbiAgICBjYXNlICdwb2x5bm9taWFsJzoge1xuICAgICAgaWYgKCFwYXJhbWV0ZXJzLnBvbHlub21pYWwpIHJldHVyblxuICAgICAgY29uc3QgeyBjb2VmZmljaWVudHMgfSA9IHBhcmFtZXRlcnMucG9seW5vbWlhbFxuICAgICAgbGV0IGZpcnN0ID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgeCA9IHhNaW47IHggPD0geE1heDsgeCArPSAwLjAxKSB7XG4gICAgICAgIGNvbnN0IHkgPSBldmFsdWF0ZVBvbHlub21pYWwoeCwgY29lZmZpY2llbnRzKVxuICAgICAgICBjb25zdCBweCA9IHRyYW5zZm9ybVgoeCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgICAgICBjb25zdCBweSA9IHRyYW5zZm9ybVkoeSwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHB4LCBweSlcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhweCwgcHkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAnYmV6aWVyJzoge1xuICAgICAgaWYgKCFwYXJhbWV0ZXJzLmJlemllcikgcmV0dXJuXG4gICAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgICBsZXQgZmlyc3QgPSB0cnVlXG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBldmFsdWF0ZUJlemllcih0LCBjb250cm9sUG9pbnRzKVxuICAgICAgICBjb25zdCBweCA9IHRyYW5zZm9ybVgocG9pbnQueCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgICAgICBjb25zdCBweSA9IHRyYW5zZm9ybVkocG9pbnQueSwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHB4LCBweSlcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhweCwgcHkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAncGFyYW1ldHJpYyc6IHtcbiAgICAgIGlmICghcGFyYW1ldGVycy5wYXJhbWV0cmljKSByZXR1cm5cbiAgICAgIGNvbnN0IHsgdE1pbiwgdE1heCwgeEZ1bmN0aW9uLCB5RnVuY3Rpb24sIHhTY2FsZSwgeVNjYWxlIH0gPSBwYXJhbWV0ZXJzLnBhcmFtZXRyaWNcbiAgICAgIGxldCBmaXJzdCA9IHRydWVcbiAgICAgIGZvciAobGV0IHQgPSB0TWluOyB0IDw9IHRNYXg7IHQgKz0gMC4wMSkge1xuICAgICAgICBjb25zdCB4ID0gZXZhbHVhdGVQYXJhbWV0cmljRnVuY3Rpb24odCwgeEZ1bmN0aW9uLCB4U2NhbGUpXG4gICAgICAgIGNvbnN0IHkgPSBldmFsdWF0ZVBhcmFtZXRyaWNGdW5jdGlvbih0LCB5RnVuY3Rpb24sIHlTY2FsZSlcbiAgICAgICAgY29uc3QgcHggPSB0cmFuc2Zvcm1YKHgsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgY29uc3QgcHkgPSB0cmFuc2Zvcm1ZKHksIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhweCwgcHkpXG4gICAgICAgICAgZmlyc3QgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lVG8ocHgsIHB5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3RyaWdvbm9tZXRyaWMnOiB7XG4gICAgICBpZiAoIXBhcmFtZXRlcnMudHJpZ29ub21ldHJpYykgcmV0dXJuXG4gICAgICBjb25zdCB7IGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwaGFzZSB9ID0gcGFyYW1ldGVycy50cmlnb25vbWV0cmljXG4gICAgICBsZXQgZmlyc3QgPSB0cnVlXG4gICAgICBmb3IgKGxldCB4ID0geE1pbjsgeCA8PSB4TWF4OyB4ICs9IDAuMDEpIHtcbiAgICAgICAgY29uc3QgeSA9IGFtcGxpdHVkZSAqIE1hdGguc2luKGZyZXF1ZW5jeSAqIHggKyBwaGFzZSlcbiAgICAgICAgY29uc3QgcHggPSB0cmFuc2Zvcm1YKHgsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgY29uc3QgcHkgPSB0cmFuc2Zvcm1ZKHksIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhweCwgcHkpXG4gICAgICAgICAgZmlyc3QgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lVG8ocHgsIHB5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ2V4cG9uZW50aWFsJzoge1xuICAgICAgaWYgKCFwYXJhbWV0ZXJzLmV4cG9uZW50aWFsKSByZXR1cm5cbiAgICAgIGNvbnN0IHsgYmFzZSwgY29lZmZpY2llbnQsIHZlcnRpY2FsU2hpZnQgfSA9IHBhcmFtZXRlcnMuZXhwb25lbnRpYWxcbiAgICAgIGxldCBmaXJzdCA9IHRydWVcbiAgICAgIGZvciAobGV0IHggPSB4TWluOyB4IDw9IHhNYXg7IHggKz0gMC4wMSkge1xuICAgICAgICBjb25zdCB5ID0gY29lZmZpY2llbnQgKiBNYXRoLnBvdyhiYXNlLCB4KSArIHZlcnRpY2FsU2hpZnRcbiAgICAgICAgY29uc3QgcHggPSB0cmFuc2Zvcm1YKHgsIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgY29uc3QgcHkgPSB0cmFuc2Zvcm1ZKHksIGRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhweCwgcHkpXG4gICAgICAgICAgZmlyc3QgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lVG8ocHgsIHB5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zdHJva2UoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0NvbnRyb2xQb2ludHMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwb2ludHM6IFBvaW50W10sXG4gIGNvbmZpZzogUmVuZGVyQ29uZmlnXG4pIHtcbiAgY3R4LmZpbGxTdHlsZSA9ICcjM2I4MmY2J1xuICBjdHguc3Ryb2tlU3R5bGUgPSAnIzI1NjNlYidcbiAgY3R4LmxpbmVXaWR0aCA9IDJcblxuICAvLyBEcmF3IGNvbnRyb2wgcG9pbnRzXG4gIHBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgIGNvbnN0IHB4ID0gdHJhbnNmb3JtWChwb2ludC54LCBjb25maWcuZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGNvbnN0IHB5ID0gdHJhbnNmb3JtWShwb2ludC55LCBjb25maWcuZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5hcmMocHgsIHB5LCA0LCAwLCAyICogTWF0aC5QSSlcbiAgICBjdHguZmlsbCgpXG4gICAgY3R4LnN0cm9rZSgpXG4gIH0pXG5cbiAgLy8gRHJhdyBjb250cm9sIGxpbmVzXG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjOTNjNWZkJ1xuICBjdHgubGluZVdpZHRoID0gMVxuICBjdHguYmVnaW5QYXRoKClcbiAgY3R4Lm1vdmVUbyhcbiAgICB0cmFuc2Zvcm1YKHBvaW50c1swXS54LCBjb25maWcuZGltZW5zaW9ucywgY29uZmlnKSxcbiAgICB0cmFuc2Zvcm1ZKHBvaW50c1swXS55LCBjb25maWcuZGltZW5zaW9ucywgY29uZmlnKVxuICApXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3R4LmxpbmVUbyhcbiAgICAgIHRyYW5zZm9ybVgocG9pbnRzW2ldLngsIGNvbmZpZy5kaW1lbnNpb25zLCBjb25maWcpLFxuICAgICAgdHJhbnNmb3JtWShwb2ludHNbaV0ueSwgY29uZmlnLmRpbWVuc2lvbnMsIGNvbmZpZylcbiAgICApXG4gIH1cbiAgY3R4LnN0cm9rZSgpXG59ICJdLCJuYW1lcyI6WyJldmFsdWF0ZVBvbHlub21pYWwiLCJldmFsdWF0ZUJlemllciIsImV2YWx1YXRlUGFyYW1ldHJpY0Z1bmN0aW9uIiwidHJhbnNmb3JtWCIsInRyYW5zZm9ybVkiLCJkcmF3R3JpZCIsImN0eCIsImNvbmZpZyIsInBhZGRpbmciLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwiZGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0Iiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJ4IiwiTWF0aCIsImNlaWwiLCJweCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImZpbGxTdHlsZSIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwidG9TdHJpbmciLCJ5IiwicHkiLCJ5QXhpcyIsInhBeGlzIiwiZHJhd0N1cnZlIiwiY3VydmVUeXBlIiwicGFyYW1ldGVycyIsInBvbHlub21pYWwiLCJjb2VmZmljaWVudHMiLCJmaXJzdCIsImJlemllciIsImNvbnRyb2xQb2ludHMiLCJ0IiwicG9pbnQiLCJwYXJhbWV0cmljIiwidE1pbiIsInRNYXgiLCJ4RnVuY3Rpb24iLCJ5RnVuY3Rpb24iLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ0cmlnb25vbWV0cmljIiwiYW1wbGl0dWRlIiwiZnJlcXVlbmN5IiwicGhhc2UiLCJzaW4iLCJleHBvbmVudGlhbCIsImJhc2UiLCJjb2VmZmljaWVudCIsInZlcnRpY2FsU2hpZnQiLCJwb3ciLCJkcmF3Q29udHJvbFBvaW50cyIsInBvaW50cyIsImZvckVhY2giLCJhcmMiLCJQSSIsImZpbGwiLCJpIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/curveRendering.ts\n"));

/***/ })

});