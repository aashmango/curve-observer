"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/CurveCanvas.tsx":
/*!****************************************!*\
  !*** ./app/components/CurveCanvas.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CurveCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/canvasUtils */ \"(app-pages-browser)/./app/lib/canvasUtils.ts\");\n/* harmony import */ var _lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/curveRendering */ \"(app-pages-browser)/./app/lib/curveRendering.ts\");\n/* harmony import */ var _lib_curveCalculations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/curveCalculations */ \"(app-pages-browser)/./app/lib/curveCalculations.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction CurveCanvas(param) {\n    let { curveType, parameters, onParameterChange } = param;\n    _s();\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [dimensions, setDimensions] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        width: 0,\n        height: 0\n    });\n    const [draggingPoint, setDraggingPoint] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n    const padding = 60;\n    const xMin = -10;\n    const xMax = 10;\n    const yMin = -10;\n    const yMax = 10;\n    const config = {\n        padding,\n        xMin,\n        xMax,\n        yMin,\n        yMax,\n        dimensions\n    };\n    const updateCanvasDimensions = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        if (canvasRef.current) {\n            const rect = canvasRef.current.getBoundingClientRect();\n            const scale = window.devicePixelRatio;\n            const width = rect.width;\n            const height = rect.height;\n            // Set the canvas dimensions to match the display size\n            canvasRef.current.width = width;\n            canvasRef.current.height = height;\n            // Update the dimensions state with the actual display size\n            setDimensions({\n                width,\n                height\n            });\n        }\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        updateCanvasDimensions();\n        window.addEventListener(\"resize\", updateCanvasDimensions);\n        return ()=>window.removeEventListener(\"resize\", updateCanvasDimensions);\n    }, [\n        updateCanvasDimensions\n    ]);\n    const handleMouseDown = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1) {\n            setDraggingPoint({\n                index: pointIndex,\n                point: controlPoints[pointIndex]\n            });\n        }\n    };\n    const handleDoubleClick = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const newPoint = {\n            x,\n            y\n        };\n        // Find the closest line segment to insert the new point\n        let minDist = Infinity;\n        let insertIndex = 0;\n        for(let i = 0; i < controlPoints.length - 1; i++){\n            const p1 = controlPoints[i];\n            const p2 = controlPoints[i + 1];\n            const dist = (0,_lib_curveCalculations__WEBPACK_IMPORTED_MODULE_4__.distanceToLineSegment)(x, y, p1.x, p1.y, p2.x, p2.y);\n            if (dist < minDist) {\n                minDist = dist;\n                insertIndex = i + 1;\n            }\n        }\n        // If no line segments found, append to the end\n        if (controlPoints.length === 0) {\n            insertIndex = 0;\n        }\n        const newPoints = [\n            ...controlPoints\n        ];\n        newPoints.splice(insertIndex, 0, newPoint);\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleContextMenu = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        e.preventDefault();\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1 && controlPoints.length > 2) {\n            const newPoints = [\n                ...controlPoints\n            ];\n            newPoints.splice(pointIndex, 1);\n            onParameterChange({\n                bezier: {\n                    ...parameters.bezier,\n                    controlPoints: newPoints\n                }\n            });\n        }\n    };\n    const handleMouseMove = (e)=>{\n        if (!draggingPoint || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformX)(e.clientX - rect.left, dimensions, config);\n        const y = (0,_lib_canvasUtils__WEBPACK_IMPORTED_MODULE_2__.inverseTransformY)(e.clientY - rect.top, dimensions, config);\n        const newPoints = [\n            ...parameters.bezier.controlPoints\n        ];\n        newPoints[draggingPoint.index] = {\n            x,\n            y\n        };\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleMouseUp = ()=>{\n        setDraggingPoint(null);\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Clear canvas\n        ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n        // Draw grid\n        (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawGrid)(ctx, config);\n        // Draw curve\n        (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawCurve)(ctx, curveType, parameters, config);\n        // Draw control points for BÃ©zier curves\n        if (curveType === \"bezier\" && parameters.bezier) {\n            (0,_lib_curveRendering__WEBPACK_IMPORTED_MODULE_3__.drawControlPoints)(ctx, parameters.bezier.controlPoints, config);\n        }\n    }, [\n        curveType,\n        parameters,\n        dimensions\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"h-full w-full rounded-lg border bg-background\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu\n    }, void 0, false, {\n        fileName: \"/Users/agoghari/curve-explorer/app/components/CurveCanvas.tsx\",\n        lineNumber: 203,\n        columnNumber: 5\n    }, this);\n}\n_s(CurveCanvas, \"QocEgTxg/sXhfs5tJdsG8nvILI8=\");\n_c = CurveCanvas;\nvar _c;\n$RefreshReg$(_c, \"CurveCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0N1cnZlQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFOEI7QUFFMEU7QUFDMUI7QUFDZDtBQVFqRCxTQUFTTyxZQUFZLEtBQThEO1FBQTlELEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxpQkFBaUIsRUFBb0IsR0FBOUQ7O0lBQ2xDLE1BQU1DLFlBQVlYLHlDQUFZLENBQW9CO0lBQ2xELE1BQU0sQ0FBQ2EsWUFBWUMsY0FBYyxHQUFHZCwyQ0FBYyxDQUFDO1FBQUVnQixPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUN6RSxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHbkIsMkNBQWMsQ0FBeUM7SUFFakcsTUFBTW9CLFVBQVU7SUFDaEIsTUFBTUMsT0FBTyxDQUFDO0lBQ2QsTUFBTUMsT0FBTztJQUNiLE1BQU1DLE9BQU8sQ0FBQztJQUNkLE1BQU1DLE9BQU87SUFFYixNQUFNQyxTQUFTO1FBQ2JMO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FYO0lBQ0Y7SUFFQSxNQUFNYSx5QkFBeUIxQiw4Q0FBaUIsQ0FBQztRQUMvQyxJQUFJVyxVQUFVaUIsT0FBTyxFQUFFO1lBQ3JCLE1BQU1DLE9BQU9sQixVQUFVaUIsT0FBTyxDQUFDRSxxQkFBcUI7WUFDcEQsTUFBTUMsUUFBUUMsT0FBT0MsZ0JBQWdCO1lBQ3JDLE1BQU1qQixRQUFRYSxLQUFLYixLQUFLO1lBQ3hCLE1BQU1DLFNBQVNZLEtBQUtaLE1BQU07WUFFMUIsc0RBQXNEO1lBQ3RETixVQUFVaUIsT0FBTyxDQUFDWixLQUFLLEdBQUdBO1lBQzFCTCxVQUFVaUIsT0FBTyxDQUFDWCxNQUFNLEdBQUdBO1lBRTNCLDJEQUEyRDtZQUMzREgsY0FBYztnQkFBRUU7Z0JBQU9DO1lBQU87UUFDaEM7SUFDRixHQUFHLEVBQUU7SUFFTGpCLDRDQUFlLENBQUM7UUFDZDBCO1FBQ0FNLE9BQU9HLGdCQUFnQixDQUFDLFVBQVVU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InNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEN1cnZlUGFyYW1ldGVycywgQ3VydmVUeXBlLCBQb2ludCB9IGZyb20gJy4uL3R5cGVzL2N1cnZlcydcbmltcG9ydCB7IHNldHVwQ2FudmFzLCBnZXRDYW52YXNDb250ZXh0LCBpbnZlcnNlVHJhbnNmb3JtWCwgaW52ZXJzZVRyYW5zZm9ybVkgfSBmcm9tICcuLi9saWIvY2FudmFzVXRpbHMnXG5pbXBvcnQgeyBkcmF3R3JpZCwgZHJhd0N1cnZlLCBkcmF3Q29udHJvbFBvaW50cyB9IGZyb20gJy4uL2xpYi9jdXJ2ZVJlbmRlcmluZydcbmltcG9ydCB7IGRpc3RhbmNlVG9MaW5lU2VnbWVudCB9IGZyb20gJy4uL2xpYi9jdXJ2ZUNhbGN1bGF0aW9ucydcblxuaW50ZXJmYWNlIEN1cnZlQ2FudmFzUHJvcHMge1xuICBjdXJ2ZVR5cGU6IEN1cnZlVHlwZVxuICBwYXJhbWV0ZXJzOiBQYXJ0aWFsPEN1cnZlUGFyYW1ldGVycz5cbiAgb25QYXJhbWV0ZXJDaGFuZ2U6IChwYXJhbXM6IFBhcnRpYWw8Q3VydmVQYXJhbWV0ZXJzPikgPT4gdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXJ2ZUNhbnZhcyh7IGN1cnZlVHlwZSwgcGFyYW1ldGVycywgb25QYXJhbWV0ZXJDaGFuZ2UgfTogQ3VydmVDYW52YXNQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IFJlYWN0LnVzZVN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KVxuICBjb25zdCBbZHJhZ2dpbmdQb2ludCwgc2V0RHJhZ2dpbmdQb2ludF0gPSBSZWFjdC51c2VTdGF0ZTx7IGluZGV4OiBudW1iZXI7IHBvaW50OiBQb2ludCB9IHwgbnVsbD4obnVsbClcblxuICBjb25zdCBwYWRkaW5nID0gNjBcbiAgY29uc3QgeE1pbiA9IC0xMFxuICBjb25zdCB4TWF4ID0gMTBcbiAgY29uc3QgeU1pbiA9IC0xMFxuICBjb25zdCB5TWF4ID0gMTBcblxuICBjb25zdCBjb25maWcgPSB7XG4gICAgcGFkZGluZyxcbiAgICB4TWluLFxuICAgIHhNYXgsXG4gICAgeU1pbixcbiAgICB5TWF4LFxuICAgIGRpbWVuc2lvbnMsXG4gIH1cblxuICBjb25zdCB1cGRhdGVDYW52YXNEaW1lbnNpb25zID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCBzY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGhcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0XG5cbiAgICAgIC8vIFNldCB0aGUgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggdGhlIGRpc3BsYXkgc2l6ZVxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSB3aWR0aFxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gaGVpZ2h0XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGltZW5zaW9ucyBzdGF0ZSB3aXRoIHRoZSBhY3R1YWwgZGlzcGxheSBzaXplXG4gICAgICBzZXREaW1lbnNpb25zKHsgd2lkdGgsIGhlaWdodCB9KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB1cGRhdGVDYW52YXNEaW1lbnNpb25zKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlQ2FudmFzRGltZW5zaW9ucylcblxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlQ2FudmFzRGltZW5zaW9ucylcbiAgfSwgW3VwZGF0ZUNhbnZhc0RpbWVuc2lvbnNdKVxuXG4gIGNvbnN0IGhhbmRsZU1vdXNlRG93biA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGlmIChjdXJ2ZVR5cGUgIT09ICdiZXppZXInIHx8ICFwYXJhbWV0ZXJzLmJlemllcikgcmV0dXJuXG5cbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgIGlmICghY2FudmFzKSByZXR1cm5cblxuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB4ID0gaW52ZXJzZVRyYW5zZm9ybVgoZS5jbGllbnRYIC0gcmVjdC5sZWZ0LCBkaW1lbnNpb25zLCBjb25maWcpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wLCBkaW1lbnNpb25zLCBjb25maWcpXG5cbiAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgY29uc3QgcG9pbnRJbmRleCA9IGNvbnRyb2xQb2ludHMuZmluZEluZGV4KChwb2ludCkgPT4ge1xuICAgICAgY29uc3QgZHggPSBwb2ludC54IC0geFxuICAgICAgY29uc3QgZHkgPSBwb2ludC55IC0geVxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgPCAwLjVcbiAgICB9KVxuXG4gICAgaWYgKHBvaW50SW5kZXggIT09IC0xKSB7XG4gICAgICBzZXREcmFnZ2luZ1BvaW50KHsgaW5kZXg6IHBvaW50SW5kZXgsIHBvaW50OiBjb250cm9sUG9pbnRzW3BvaW50SW5kZXhdIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlRG91YmxlQ2xpY2sgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBpZiAoY3VydmVUeXBlICE9PSAnYmV6aWVyJyB8fCAhcGFyYW1ldGVycy5iZXppZXIpIHJldHVyblxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGNvbnN0IHkgPSBpbnZlcnNlVHJhbnNmb3JtWShlLmNsaWVudFkgLSByZWN0LnRvcCwgZGltZW5zaW9ucywgY29uZmlnKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IG5ld1BvaW50ID0geyB4LCB5IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgbGluZSBzZWdtZW50IHRvIGluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgbGV0IG1pbkRpc3QgPSBJbmZpbml0eVxuICAgIGxldCBpbnNlcnRJbmRleCA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHAxID0gY29udHJvbFBvaW50c1tpXVxuICAgICAgY29uc3QgcDIgPSBjb250cm9sUG9pbnRzW2kgKyAxXVxuICAgICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBwMS54LCBwMS55LCBwMi54LCBwMi55KVxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBsaW5lIHNlZ21lbnRzIGZvdW5kLCBhcHBlbmQgdG8gdGhlIGVuZFxuICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0SW5kZXggPSAwXG4gICAgfVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpXG5cbiAgICBvblBhcmFtZXRlckNoYW5nZSh7XG4gICAgICBiZXppZXI6IHtcbiAgICAgICAgLi4ucGFyYW1ldGVycy5iZXppZXIsXG4gICAgICAgIGNvbnRyb2xQb2ludHM6IG5ld1BvaW50cyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZGltZW5zaW9ucywgY29uZmlnKVxuICAgIGNvbnN0IHkgPSBpbnZlcnNlVHJhbnNmb3JtWShlLmNsaWVudFkgLSByZWN0LnRvcCwgZGltZW5zaW9ucywgY29uZmlnKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IHBvaW50SW5kZXggPSBjb250cm9sUG9pbnRzLmZpbmRJbmRleCgocG9pbnQpID0+IHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnQueCAtIHhcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnQueSAtIHlcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDwgMC41XG4gICAgfSlcblxuICAgIGlmIChwb2ludEluZGV4ICE9PSAtMSAmJiBjb250cm9sUG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IFsuLi5jb250cm9sUG9pbnRzXVxuICAgICAgbmV3UG9pbnRzLnNwbGljZShwb2ludEluZGV4LCAxKVxuXG4gICAgICBvblBhcmFtZXRlckNoYW5nZSh7XG4gICAgICAgIGJlemllcjoge1xuICAgICAgICAgIC4uLnBhcmFtZXRlcnMuYmV6aWVyLFxuICAgICAgICAgIGNvbnRyb2xQb2ludHM6IG5ld1BvaW50cyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKCFkcmFnZ2luZ1BvaW50IHx8ICFwYXJhbWV0ZXJzLmJlemllcikgcmV0dXJuXG5cbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgIGlmICghY2FudmFzKSByZXR1cm5cblxuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB4ID0gaW52ZXJzZVRyYW5zZm9ybVgoZS5jbGllbnRYIC0gcmVjdC5sZWZ0LCBkaW1lbnNpb25zLCBjb25maWcpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wLCBkaW1lbnNpb25zLCBjb25maWcpXG5cbiAgICBjb25zdCBuZXdQb2ludHMgPSBbLi4ucGFyYW1ldGVycy5iZXppZXIuY29udHJvbFBvaW50c11cbiAgICBuZXdQb2ludHNbZHJhZ2dpbmdQb2ludC5pbmRleF0gPSB7IHgsIHkgfVxuXG4gICAgb25QYXJhbWV0ZXJDaGFuZ2Uoe1xuICAgICAgYmV6aWVyOiB7XG4gICAgICAgIC4uLnBhcmFtZXRlcnMuYmV6aWVyLFxuICAgICAgICBjb250cm9sUG9pbnRzOiBuZXdQb2ludHMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gKCkgPT4ge1xuICAgIHNldERyYWdnaW5nUG9pbnQobnVsbClcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGlmICghY3R4KSByZXR1cm5cblxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpXG5cbiAgICAvLyBEcmF3IGdyaWRcbiAgICBkcmF3R3JpZChjdHgsIGNvbmZpZylcblxuICAgIC8vIERyYXcgY3VydmVcbiAgICBkcmF3Q3VydmUoY3R4LCBjdXJ2ZVR5cGUsIHBhcmFtZXRlcnMsIGNvbmZpZylcblxuICAgIC8vIERyYXcgY29udHJvbCBwb2ludHMgZm9yIELDqXppZXIgY3VydmVzXG4gICAgaWYgKGN1cnZlVHlwZSA9PT0gJ2JlemllcicgJiYgcGFyYW1ldGVycy5iZXppZXIpIHtcbiAgICAgIGRyYXdDb250cm9sUG9pbnRzKGN0eCwgcGFyYW1ldGVycy5iZXppZXIuY29udHJvbFBvaW50cywgY29uZmlnKVxuICAgIH1cbiAgfSwgW2N1cnZlVHlwZSwgcGFyYW1ldGVycywgZGltZW5zaW9uc10pXG5cbiAgcmV0dXJuIChcbiAgICA8Y2FudmFzXG4gICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgIGNsYXNzTmFtZT1cImgtZnVsbCB3LWZ1bGwgcm91bmRlZC1sZyBib3JkZXIgYmctYmFja2dyb3VuZFwiXG4gICAgICBvbk1vdXNlRG93bj17aGFuZGxlTW91c2VEb3dufVxuICAgICAgb25Nb3VzZU1vdmU9e2hhbmRsZU1vdXNlTW92ZX1cbiAgICAgIG9uTW91c2VVcD17aGFuZGxlTW91c2VVcH1cbiAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlTW91c2VVcH1cbiAgICAgIG9uRG91YmxlQ2xpY2s9e2hhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgb25Db250ZXh0TWVudT17aGFuZGxlQ29udGV4dE1lbnV9XG4gICAgLz5cbiAgKVxufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJpbnZlcnNlVHJhbnNmb3JtWCIsImludmVyc2VUcmFuc2Zvcm1ZIiwiZHJhd0dyaWQiLCJkcmF3Q3VydmUiLCJkcmF3Q29udHJvbFBvaW50cyIsImRpc3RhbmNlVG9MaW5lU2VnbWVudCIsIkN1cnZlQ2FudmFzIiwiY3VydmVUeXBlIiwicGFyYW1ldGVycyIsIm9uUGFyYW1ldGVyQ2hhbmdlIiwiY2FudmFzUmVmIiwidXNlUmVmIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJ1c2VTdGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhZ2dpbmdQb2ludCIsInNldERyYWdnaW5nUG9pbnQiLCJwYWRkaW5nIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsImNvbmZpZyIsInVwZGF0ZUNhbnZhc0RpbWVuc2lvbnMiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGUiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwidXNlRWZmZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVNb3VzZURvd24iLCJlIiwiYmV6aWVyIiwiY2FudmFzIiwieCIsImNsaWVudFgiLCJsZWZ0IiwieSIsImNsaWVudFkiLCJ0b3AiLCJjb250cm9sUG9pbnRzIiwicG9pbnRJbmRleCIsImZpbmRJbmRleCIsInBvaW50IiwiZHgiLCJkeSIsIk1hdGgiLCJzcXJ0IiwiaW5kZXgiLCJoYW5kbGVEb3VibGVDbGljayIsIm5ld1BvaW50IiwibWluRGlzdCIsIkluZmluaXR5IiwiaW5zZXJ0SW5kZXgiLCJpIiwibGVuZ3RoIiwicDEiLCJwMiIsImRpc3QiLCJuZXdQb2ludHMiLCJzcGxpY2UiLCJoYW5kbGVDb250ZXh0TWVudSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJyZWYiLCJjbGFzc05hbWUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm9uQ29udGV4dE1lbnUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/CurveCanvas.tsx\n"));

/***/ })

});