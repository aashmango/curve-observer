"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/CurveCanvas.tsx":
/*!****************************************!*\
  !*** ./app/components/CurveCanvas.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CurveCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction evaluatePolynomial(x, coefficients) {\n    return coefficients.reduce((sum, coeff, i)=>{\n        return sum + coeff * Math.pow(x, coefficients.length - 1 - i);\n    }, 0);\n}\nfunction evaluateBezier(t, points) {\n    if (points.length === 1) return points[0];\n    const newPoints = [];\n    for(let i = 0; i < points.length - 1; i++){\n        newPoints.push({\n            x: (1 - t) * points[i].x + t * points[i + 1].x,\n            y: (1 - t) * points[i].y + t * points[i + 1].y\n        });\n    }\n    return evaluateBezier(t, newPoints);\n}\nfunction getIntermediatePoints(t, points) {\n    if (points.length <= 1) return [\n        points\n    ];\n    const result = [\n        points\n    ];\n    let currentPoints = points;\n    while(currentPoints.length > 1){\n        const newPoints = [];\n        for(let i = 0; i < currentPoints.length - 1; i++){\n            newPoints.push({\n                x: (1 - t) * currentPoints[i].x + t * currentPoints[i + 1].x,\n                y: (1 - t) * currentPoints[i].y + t * currentPoints[i + 1].y\n            });\n        }\n        result.push(newPoints);\n        currentPoints = newPoints;\n    }\n    return result;\n}\nfunction CurveCanvas(param) {\n    let { curveType, parameters, onParameterChange } = param;\n    _s();\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [dimensions, setDimensions] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        width: 0,\n        height: 0\n    });\n    const [draggingPoint, setDraggingPoint] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n    const padding = 60;\n    const xMin = -10;\n    const xMax = 10;\n    const yMin = -10;\n    const yMax = 10;\n    const transformX = (x)=>(x - xMin) / (xMax - xMin) * (dimensions.width - 2 * padding) + padding;\n    const transformY = (y)=>dimensions.height - ((y - yMin) / (yMax - yMin) * (dimensions.height - 2 * padding) + padding);\n    const inverseTransformX = (px)=>(px - padding) / (dimensions.width - 2 * padding) * (xMax - xMin) + xMin;\n    const inverseTransformY = (py)=>yMax - (py - padding) / (dimensions.height - 2 * padding) * (yMax - yMin);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const updateDimensions = ()=>{\n            if (canvasRef.current) {\n                const { width, height } = canvasRef.current.getBoundingClientRect();\n                setDimensions({\n                    width,\n                    height\n                });\n                canvasRef.current.width = width;\n                canvasRef.current.height = height;\n            }\n        };\n        window.addEventListener(\"resize\", updateDimensions);\n        updateDimensions();\n        return ()=>window.removeEventListener(\"resize\", updateDimensions);\n    }, []);\n    const handleMouseDown = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1) {\n            setDraggingPoint({\n                index: pointIndex,\n                point: controlPoints[pointIndex]\n            });\n        }\n    };\n    const handleDoubleClick = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const newPoint = {\n            x,\n            y\n        };\n        // Find the closest line segment to insert the new point\n        let minDist = Infinity;\n        let insertIndex = 0;\n        for(let i = 0; i < controlPoints.length - 1; i++){\n            const p1 = controlPoints[i];\n            const p2 = controlPoints[i + 1];\n            const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);\n            if (dist < minDist) {\n                minDist = dist;\n                insertIndex = i + 1;\n            }\n        }\n        // If no line segments found, append to the end\n        if (controlPoints.length === 0) {\n            insertIndex = 0;\n        }\n        const newPoints = [\n            ...controlPoints\n        ];\n        newPoints.splice(insertIndex, 0, newPoint);\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleContextMenu = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        e.preventDefault();\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1 && controlPoints.length > 2) {\n            const newPoints = [\n                ...controlPoints\n            ];\n            newPoints.splice(pointIndex, 1);\n            onParameterChange({\n                bezier: {\n                    ...parameters.bezier,\n                    controlPoints: newPoints\n                }\n            });\n        }\n    };\n    const distanceToLineSegment = (x, y, x1, y1, x2, y2)=>{\n        const A = x - x1;\n        const B = y - y1;\n        const C = x2 - x1;\n        const D = y2 - y1;\n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        if (lenSq !== 0) {\n            param = dot / lenSq;\n        }\n        let xx, yy;\n        if (param < 0) {\n            xx = x1;\n            yy = y1;\n        } else if (param > 1) {\n            xx = x2;\n            yy = y2;\n        } else {\n            xx = x1 + param * C;\n            yy = y1 + param * D;\n        }\n        const dx = x - xx;\n        const dy = y - yy;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    const handleMouseMove = (e)=>{\n        if (!draggingPoint || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const newPoints = [\n            ...parameters.bezier.controlPoints\n        ];\n        newPoints[draggingPoint.index] = {\n            x,\n            y\n        };\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleMouseUp = ()=>{\n        setDraggingPoint(null);\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const { width, height } = dimensions;\n        // Set canvas scale for retina displays\n        const scale = window.devicePixelRatio;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        ctx.scale(scale, scale);\n        // Clear canvas\n        ctx.clearRect(0, 0, width, height);\n        // Draw axes\n        ctx.beginPath();\n        ctx.strokeStyle = \"#666\";\n        ctx.lineWidth = 1;\n        // X-axis\n        ctx.moveTo(padding, transformY(0));\n        ctx.lineTo(width - padding, transformY(0));\n        // Y-axis\n        ctx.moveTo(transformX(0), height - padding);\n        ctx.lineTo(transformX(0), padding);\n        ctx.stroke();\n        // Draw grid\n        ctx.beginPath();\n        ctx.strokeStyle = \"#ddd\";\n        ctx.lineWidth = 0.5;\n        for(let x = Math.ceil(xMin); x <= Math.floor(xMax); x++){\n            if (x === 0) continue;\n            ctx.moveTo(transformX(x), padding);\n            ctx.lineTo(transformX(x), height - padding);\n        }\n        for(let y = Math.ceil(yMin); y <= Math.floor(yMax); y++){\n            if (y === 0) continue;\n            ctx.moveTo(padding, transformY(y));\n            ctx.lineTo(width - padding, transformY(y));\n        }\n        ctx.stroke();\n        // Draw curve\n        ctx.beginPath();\n        ctx.strokeStyle = \"#2563eb\";\n        ctx.lineWidth = 2;\n        const evaluateParametricFunction = function(t, fn) {\n            let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n            switch(fn){\n                case \"cos\":\n                    return scale * Math.cos(t);\n                case \"sin\":\n                    return scale * Math.sin(t);\n                case \"t\":\n                    return scale * t;\n                case \"t^2\":\n                    return scale * t * t;\n                default:\n                    return 0;\n            }\n        };\n        const drawCurve = ()=>{\n            switch(curveType){\n                case \"polynomial\":\n                    {\n                        if (!parameters.polynomial) return;\n                        const { coefficients } = parameters.polynomial;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = evaluatePolynomial(x, coefficients);\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"bezier\":\n                    {\n                        if (!parameters.bezier) return;\n                        const { controlPoints } = parameters.bezier;\n                        // Draw control points\n                        ctx.save();\n                        ctx.fillStyle = \"#ef4444\";\n                        controlPoints.forEach((point)=>{\n                            ctx.beginPath();\n                            ctx.arc(transformX(point.x), transformY(point.y), 4, 0, 2 * Math.PI);\n                            ctx.fill();\n                        });\n                        ctx.restore();\n                        // Draw control lines\n                        ctx.beginPath();\n                        ctx.strokeStyle = \"#ddd\";\n                        ctx.lineWidth = 1;\n                        for(let i = 0; i < controlPoints.length - 1; i++){\n                            ctx.moveTo(transformX(controlPoints[i].x), transformY(controlPoints[i].y));\n                            ctx.lineTo(transformX(controlPoints[i + 1].x), transformY(controlPoints[i + 1].y));\n                        }\n                        ctx.stroke();\n                        // Draw intermediate points and lines for each step of the algorithm\n                        const steps = 20 // Number of steps to show in the visualization\n                        ;\n                        for(let step = 0; step <= steps; step++){\n                            const t = step / steps;\n                            const intermediatePoints = getIntermediatePoints(t, controlPoints);\n                            // Draw intermediate points and lines with decreasing opacity\n                            for(let i = 0; i < intermediatePoints.length; i++){\n                                const points = intermediatePoints[i];\n                                const opacity = 1 - i / intermediatePoints.length * 0.7;\n                                // Draw intermediate points\n                                ctx.save();\n                                ctx.fillStyle = \"rgba(239, 68, 68, \".concat(opacity, \")\");\n                                points.forEach((point)=>{\n                                    ctx.beginPath();\n                                    ctx.arc(transformX(point.x), transformY(point.y), 2, 0, 2 * Math.PI);\n                                    ctx.fill();\n                                });\n                                ctx.restore();\n                                // Draw intermediate lines\n                                if (points.length > 1) {\n                                    ctx.beginPath();\n                                    ctx.strokeStyle = \"rgba(221, 221, 221, \".concat(opacity, \")\");\n                                    ctx.lineWidth = 1;\n                                    for(let j = 0; j < points.length - 1; j++){\n                                        ctx.moveTo(transformX(points[j].x), transformY(points[j].y));\n                                        ctx.lineTo(transformX(points[j + 1].x), transformY(points[j + 1].y));\n                                    }\n                                    ctx.stroke();\n                                }\n                            }\n                        }\n                        // Draw final curve\n                        ctx.beginPath();\n                        ctx.strokeStyle = \"#2563eb\";\n                        ctx.lineWidth = 2;\n                        for(let t = 0; t <= 1; t += 0.01){\n                            const point = evaluateBezier(t, controlPoints);\n                            if (t === 0) {\n                                ctx.moveTo(transformX(point.x), transformY(point.y));\n                            } else {\n                                ctx.lineTo(transformX(point.x), transformY(point.y));\n                            }\n                        }\n                        break;\n                    }\n                case \"parametric\":\n                    {\n                        if (!parameters.parametric) return;\n                        const { tMin, tMax, xFunction, yFunction, xScale, yScale } = parameters.parametric;\n                        const steps = Math.max(100, Math.abs(tMax - tMin) * 50);\n                        const dt = (tMax - tMin) / steps;\n                        for(let i = 0; i <= steps; i++){\n                            const t = tMin + i * dt;\n                            const x = evaluateParametricFunction(t, xFunction, xScale);\n                            const y = evaluateParametricFunction(t, yFunction, yScale);\n                            if (i === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"trigonometric\":\n                    {\n                        if (!parameters.trigonometric) return;\n                        const { amplitude, frequency, phase } = parameters.trigonometric;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = amplitude * Math.sin(frequency * x + phase);\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"exponential\":\n                    {\n                        if (!parameters.exponential) return;\n                        const { base, coefficient, verticalShift } = parameters.exponential;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = coefficient * Math.pow(base, x) + verticalShift;\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n            }\n        };\n        drawCurve();\n        ctx.stroke();\n    }, [\n        curveType,\n        parameters,\n        dimensions,\n        transformX,\n        transformY,\n        inverseTransformX,\n        inverseTransformY\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"h-full w-full rounded-lg border bg-background\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu\n    }, void 0, false, {\n        fileName: \"/Users/agoghari/curve-explorer/app/components/CurveCanvas.tsx\",\n        lineNumber: 453,\n        columnNumber: 5\n    }, this);\n}\n_s(CurveCanvas, \"YabCTyuMquUxp7gR26CrjMOV5Fg=\");\n_c = CurveCanvas;\nvar _c;\n$RefreshReg$(_c, \"CurveCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0N1cnZlQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFOEI7QUFTOUIsU0FBU0MsbUJBQW1CQyxDQUFTLEVBQUVDLFlBQXNCO0lBQzNELE9BQU9BLGFBQWFDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFPQztRQUN0QyxPQUFPRixNQUFNQyxRQUFRRSxLQUFLQyxHQUFHLENBQUNQLEdBQUdDLGFBQWFPLE1BQU0sR0FBRyxJQUFJSDtJQUM3RCxHQUFHO0FBQ0w7QUFFQSxTQUFTSSxlQUFlQyxDQUFTLEVBQUVDLE1BQWU7SUFDaEQsSUFBSUEsT0FBT0gsTUFBTSxLQUFLLEdBQUcsT0FBT0csTUFBTSxDQUFDLEVBQUU7SUFDekMsTUFBTUMsWUFBcUIsRUFBRTtJQUM3QixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSU0sT0FBT0gsTUFBTSxHQUFHLEdBQUdILElBQUs7UUFDMUNPLFVBQVVDLElBQUksQ0FBQztZQUNiYixHQUFHLENBQUMsSUFBSVUsQ0FBQUEsSUFBS0MsTUFBTSxDQUFDTixFQUFFLENBQUNMLENBQUMsR0FBR1UsSUFBSUMsTUFBTSxDQUFDTixJQUFJLEVBQUUsQ0FBQ0wsQ0FBQztZQUM5Q2MsR0FBRyxDQUFDLElBQUlKLENBQUFBLElBQUtDLE1BQU0sQ0FBQ04sRUFBRSxDQUFDUyxDQUFDLEdBQUdKLElBQUlDLE1BQU0sQ0FBQ04sSUFBSSxFQUFFLENBQUNTLENBQUM7UUFDaEQ7SUFDRjtJQUNBLE9BQU9MLGVBQWVDLEdBQUdFO0FBQzNCO0FBRUEsU0FBU0csc0JBQXNCTCxDQUFTLEVBQUVDLE1BQWU7SUFDdkQsSUFBSUEsT0FBT0gsTUFBTSxJQUFJLEdBQUcsT0FBTztRQUFDRztLQUFPO0lBRXZDLE1BQU1LLFNBQW9CO1FBQUNMO0tBQU87SUFDbEMsSUFBSU0sZ0JBQWdCTjtJQUVwQixNQUFPTSxjQUFjVCxNQUFNLEdBQUcsRUFBRztRQUMvQixNQUFNSSxZQUFxQixF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Q0FBQ00sV0FBV3NILFdBQVcsRUFBRTt3QkFDN0IsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUd6SCxXQUFXc0gsV0FBVzt3QkFDbkUsSUFBSyxJQUFJbkcsS0FBSyxHQUFHQSxNQUFNWixPQUFPWSxLQUFNOzRCQUNsQyxNQUFNdkMsSUFBSXNDLGtCQUFrQkM7NEJBQzVCLE1BQU16QixJQUFJOEgsY0FBY3RJLEtBQUtDLEdBQUcsQ0FBQ29JLE1BQU0zSSxLQUFLNkk7NEJBQzVDLElBQUl0RyxPQUFPLEdBQUc7Z0NBQ1pzRCxJQUFJUSxNQUFNLENBQUNqRSxXQUFXcEMsSUFBSXFDLFdBQVd2Qjs0QkFDdkMsT0FBTztnQ0FDTCtFLElBQUlTLE1BQU0sQ0FBQ2xFLFdBQVdwQyxJQUFJcUMsV0FBV3ZCOzRCQUN2Qzt3QkFDRjt3QkFDQTtvQkFDRjtZQUNGO1FBQ0Y7UUFFQWdHO1FBQ0FqQixJQUFJVSxNQUFNO0lBQ1osR0FBRztRQUFDcEY7UUFBV0M7UUFBWUk7UUFBWVk7UUFBWUM7UUFBWUM7UUFBbUJFO0tBQWtCO0lBRXBHLHFCQUNFLDhEQUFDWTtRQUNDMEYsS0FBS3hIO1FBQ0x5SCxXQUFVO1FBQ1ZDLGFBQWEvRjtRQUNiZ0csYUFBYXREO1FBQ2J1RCxXQUFXdEQ7UUFDWHVELGNBQWN2RDtRQUNkd0QsZUFBZWxGO1FBQ2ZtRixlQUFlekU7Ozs7OztBQUdyQjtHQTdad0IxRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9DdXJ2ZUNhbnZhcy50c3g/ZjQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDdXJ2ZVBhcmFtZXRlcnMsIEN1cnZlVHlwZSwgUG9pbnQgfSBmcm9tICcuLi90eXBlcy9jdXJ2ZXMnXG5cbnR5cGUgQ3VydmVDYW52YXNQcm9wcyA9IHtcbiAgY3VydmVUeXBlOiBDdXJ2ZVR5cGVcbiAgcGFyYW1ldGVyczogUGFydGlhbDxDdXJ2ZVBhcmFtZXRlcnM+XG4gIG9uUGFyYW1ldGVyQ2hhbmdlOiAocGFyYW1zOiBQYXJ0aWFsPEN1cnZlUGFyYW1ldGVycz4pID0+IHZvaWRcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVQb2x5bm9taWFsKHg6IG51bWJlciwgY29lZmZpY2llbnRzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIHJldHVybiBjb2VmZmljaWVudHMucmVkdWNlKChzdW0sIGNvZWZmLCBpKSA9PiB7XG4gICAgcmV0dXJuIHN1bSArIGNvZWZmICogTWF0aC5wb3coeCwgY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBpKVxuICB9LCAwKVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUJlemllcih0OiBudW1iZXIsIHBvaW50czogUG9pbnRbXSk6IFBvaW50IHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwb2ludHNbMF1cbiAgY29uc3QgbmV3UG9pbnRzOiBQb2ludFtdID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgbmV3UG9pbnRzLnB1c2goe1xuICAgICAgeDogKDEgLSB0KSAqIHBvaW50c1tpXS54ICsgdCAqIHBvaW50c1tpICsgMV0ueCxcbiAgICAgIHk6ICgxIC0gdCkgKiBwb2ludHNbaV0ueSArIHQgKiBwb2ludHNbaSArIDFdLnksXG4gICAgfSlcbiAgfVxuICByZXR1cm4gZXZhbHVhdGVCZXppZXIodCwgbmV3UG9pbnRzKVxufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm1lZGlhdGVQb2ludHModDogbnVtYmVyLCBwb2ludHM6IFBvaW50W10pOiBQb2ludFtdW10ge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKSByZXR1cm4gW3BvaW50c11cbiAgXG4gIGNvbnN0IHJlc3VsdDogUG9pbnRbXVtdID0gW3BvaW50c11cbiAgbGV0IGN1cnJlbnRQb2ludHMgPSBwb2ludHNcbiAgXG4gIHdoaWxlIChjdXJyZW50UG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuZXdQb2ludHM6IFBvaW50W10gPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIG5ld1BvaW50cy5wdXNoKHtcbiAgICAgICAgeDogKDEgLSB0KSAqIGN1cnJlbnRQb2ludHNbaV0ueCArIHQgKiBjdXJyZW50UG9pbnRzW2kgKyAxXS54LFxuICAgICAgICB5OiAoMSAtIHQpICogY3VycmVudFBvaW50c1tpXS55ICsgdCAqIGN1cnJlbnRQb2ludHNbaSArIDFdLnksXG4gICAgICB9KVxuICAgIH1cbiAgICByZXN1bHQucHVzaChuZXdQb2ludHMpXG4gICAgY3VycmVudFBvaW50cyA9IG5ld1BvaW50c1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN1cnZlQ2FudmFzKHsgY3VydmVUeXBlLCBwYXJhbWV0ZXJzLCBvblBhcmFtZXRlckNoYW5nZSB9OiBDdXJ2ZUNhbnZhc1Byb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gUmVhY3QudXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pXG4gIGNvbnN0IFtkcmFnZ2luZ1BvaW50LCBzZXREcmFnZ2luZ1BvaW50XSA9IFJlYWN0LnVzZVN0YXRlPHsgaW5kZXg6IG51bWJlcjsgcG9pbnQ6IFBvaW50IH0gfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHBhZGRpbmcgPSA2MFxuICBjb25zdCB4TWluID0gLTEwXG4gIGNvbnN0IHhNYXggPSAxMFxuICBjb25zdCB5TWluID0gLTEwXG4gIGNvbnN0IHlNYXggPSAxMFxuXG4gIGNvbnN0IHRyYW5zZm9ybVggPSAoeDogbnVtYmVyKSA9PiAoKHggLSB4TWluKSAvICh4TWF4IC0geE1pbikpICogKGRpbWVuc2lvbnMud2lkdGggLSAyICogcGFkZGluZykgKyBwYWRkaW5nXG4gIGNvbnN0IHRyYW5zZm9ybVkgPSAoeTogbnVtYmVyKSA9PiBkaW1lbnNpb25zLmhlaWdodCAtICgoKHkgLSB5TWluKSAvICh5TWF4IC0geU1pbikpICogKGRpbWVuc2lvbnMuaGVpZ2h0IC0gMiAqIHBhZGRpbmcpICsgcGFkZGluZylcbiAgY29uc3QgaW52ZXJzZVRyYW5zZm9ybVggPSAocHg6IG51bWJlcikgPT4gKChweCAtIHBhZGRpbmcpIC8gKGRpbWVuc2lvbnMud2lkdGggLSAyICogcGFkZGluZykpICogKHhNYXggLSB4TWluKSArIHhNaW5cbiAgY29uc3QgaW52ZXJzZVRyYW5zZm9ybVkgPSAocHk6IG51bWJlcikgPT4geU1heCAtICgocHkgLSBwYWRkaW5nKSAvIChkaW1lbnNpb25zLmhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKiAoeU1heCAtIHlNaW4pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgc2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSlcbiAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSB3aWR0aFxuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucylcbiAgICB1cGRhdGVEaW1lbnNpb25zKClcblxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucylcbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlTW91c2VEb3duID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IHBvaW50SW5kZXggPSBjb250cm9sUG9pbnRzLmZpbmRJbmRleCgocG9pbnQpID0+IHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnQueCAtIHhcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnQueSAtIHlcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDwgMC41XG4gICAgfSlcblxuICAgIGlmIChwb2ludEluZGV4ICE9PSAtMSkge1xuICAgICAgc2V0RHJhZ2dpbmdQb2ludCh7IGluZGV4OiBwb2ludEluZGV4LCBwb2ludDogY29udHJvbFBvaW50c1twb2ludEluZGV4XSB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IG5ld1BvaW50ID0geyB4LCB5IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgbGluZSBzZWdtZW50IHRvIGluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgbGV0IG1pbkRpc3QgPSBJbmZpbml0eVxuICAgIGxldCBpbnNlcnRJbmRleCA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHAxID0gY29udHJvbFBvaW50c1tpXVxuICAgICAgY29uc3QgcDIgPSBjb250cm9sUG9pbnRzW2kgKyAxXVxuICAgICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBwMS54LCBwMS55LCBwMi54LCBwMi55KVxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBsaW5lIHNlZ21lbnRzIGZvdW5kLCBhcHBlbmQgdG8gdGhlIGVuZFxuICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0SW5kZXggPSAwXG4gICAgfVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpXG5cbiAgICBvblBhcmFtZXRlckNoYW5nZSh7XG4gICAgICBiZXppZXI6IHtcbiAgICAgICAgLi4ucGFyYW1ldGVycy5iZXppZXIsXG4gICAgICAgIGNvbnRyb2xQb2ludHM6IG5ld1BvaW50cyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdClcbiAgICBjb25zdCB5ID0gaW52ZXJzZVRyYW5zZm9ybVkoZS5jbGllbnRZIC0gcmVjdC50b3ApXG5cbiAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgY29uc3QgcG9pbnRJbmRleCA9IGNvbnRyb2xQb2ludHMuZmluZEluZGV4KChwb2ludCkgPT4ge1xuICAgICAgY29uc3QgZHggPSBwb2ludC54IC0geFxuICAgICAgY29uc3QgZHkgPSBwb2ludC55IC0geVxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgPCAwLjVcbiAgICB9KVxuXG4gICAgaWYgKHBvaW50SW5kZXggIT09IC0xICYmIGNvbnRyb2xQb2ludHMubGVuZ3RoID4gMikge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLmNvbnRyb2xQb2ludHNdXG4gICAgICBuZXdQb2ludHMuc3BsaWNlKHBvaW50SW5kZXgsIDEpXG5cbiAgICAgIG9uUGFyYW1ldGVyQ2hhbmdlKHtcbiAgICAgICAgYmV6aWVyOiB7XG4gICAgICAgICAgLi4ucGFyYW1ldGVycy5iZXppZXIsXG4gICAgICAgICAgY29udHJvbFBvaW50czogbmV3UG9pbnRzLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXN0YW5jZVRvTGluZVNlZ21lbnQgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IEEgPSB4IC0geDFcbiAgICBjb25zdCBCID0geSAtIHkxXG4gICAgY29uc3QgQyA9IHgyIC0geDFcbiAgICBjb25zdCBEID0geTIgLSB5MVxuXG4gICAgY29uc3QgZG90ID0gQSAqIEMgKyBCICogRFxuICAgIGNvbnN0IGxlblNxID0gQyAqIEMgKyBEICogRFxuICAgIGxldCBwYXJhbSA9IC0xXG5cbiAgICBpZiAobGVuU3EgIT09IDApIHtcbiAgICAgIHBhcmFtID0gZG90IC8gbGVuU3FcbiAgICB9XG5cbiAgICBsZXQgeHgsIHl5XG5cbiAgICBpZiAocGFyYW0gPCAwKSB7XG4gICAgICB4eCA9IHgxXG4gICAgICB5eSA9IHkxXG4gICAgfSBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgIHh4ID0geDJcbiAgICAgIHl5ID0geTJcbiAgICB9IGVsc2Uge1xuICAgICAgeHggPSB4MSArIHBhcmFtICogQ1xuICAgICAgeXkgPSB5MSArIHBhcmFtICogRFxuICAgIH1cblxuICAgIGNvbnN0IGR4ID0geCAtIHh4XG4gICAgY29uc3QgZHkgPSB5IC0geXlcblxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gIH1cblxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nUG9pbnQgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnBhcmFtZXRlcnMuYmV6aWVyLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzW2RyYWdnaW5nUG9pbnQuaW5kZXhdID0geyB4LCB5IH1cblxuICAgIG9uUGFyYW1ldGVyQ2hhbmdlKHtcbiAgICAgIGJlemllcjoge1xuICAgICAgICAuLi5wYXJhbWV0ZXJzLmJlemllcixcbiAgICAgICAgY29udHJvbFBvaW50czogbmV3UG9pbnRzLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICBzZXREcmFnZ2luZ1BvaW50KG51bGwpXG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBpZiAoIWN0eCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbWVuc2lvbnNcblxuICAgIC8vIFNldCBjYW52YXMgc2NhbGUgZm9yIHJldGluYSBkaXNwbGF5c1xuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHNjYWxlXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlXG4gICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSlcblxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcblxuICAgIC8vIERyYXcgYXhlc1xuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNjY2J1xuICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgXG4gICAgLy8gWC1heGlzXG4gICAgY3R4Lm1vdmVUbyhwYWRkaW5nLCB0cmFuc2Zvcm1ZKDApKVxuICAgIGN0eC5saW5lVG8od2lkdGggLSBwYWRkaW5nLCB0cmFuc2Zvcm1ZKDApKVxuICAgIFxuICAgIC8vIFktYXhpc1xuICAgIGN0eC5tb3ZlVG8odHJhbnNmb3JtWCgwKSwgaGVpZ2h0IC0gcGFkZGluZylcbiAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoMCksIHBhZGRpbmcpXG4gICAgXG4gICAgY3R4LnN0cm9rZSgpXG5cbiAgICAvLyBEcmF3IGdyaWRcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2RkZCdcbiAgICBjdHgubGluZVdpZHRoID0gMC41XG5cbiAgICBmb3IgKGxldCB4ID0gTWF0aC5jZWlsKHhNaW4pOyB4IDw9IE1hdGguZmxvb3IoeE1heCk7IHgrKykge1xuICAgICAgaWYgKHggPT09IDApIGNvbnRpbnVlXG4gICAgICBjdHgubW92ZVRvKHRyYW5zZm9ybVgoeCksIHBhZGRpbmcpXG4gICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoeCksIGhlaWdodCAtIHBhZGRpbmcpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgeSA9IE1hdGguY2VpbCh5TWluKTsgeSA8PSBNYXRoLmZsb29yKHlNYXgpOyB5KyspIHtcbiAgICAgIGlmICh5ID09PSAwKSBjb250aW51ZVxuICAgICAgY3R4Lm1vdmVUbyhwYWRkaW5nLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgY3R4LmxpbmVUbyh3aWR0aCAtIHBhZGRpbmcsIHRyYW5zZm9ybVkoeSkpXG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZSgpXG5cbiAgICAvLyBEcmF3IGN1cnZlXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyMyNTYzZWInXG4gICAgY3R4LmxpbmVXaWR0aCA9IDJcblxuICAgIGNvbnN0IGV2YWx1YXRlUGFyYW1ldHJpY0Z1bmN0aW9uID0gKHQ6IG51bWJlciwgZm46IHN0cmluZywgc2NhbGU6IG51bWJlciA9IDEpOiBudW1iZXIgPT4ge1xuICAgICAgc3dpdGNoIChmbikge1xuICAgICAgICBjYXNlICdjb3MnOlxuICAgICAgICAgIHJldHVybiBzY2FsZSAqIE1hdGguY29zKHQpXG4gICAgICAgIGNhc2UgJ3Npbic6XG4gICAgICAgICAgcmV0dXJuIHNjYWxlICogTWF0aC5zaW4odClcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgcmV0dXJuIHNjYWxlICogdFxuICAgICAgICBjYXNlICd0XjInOlxuICAgICAgICAgIHJldHVybiBzY2FsZSAqIHQgKiB0XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkcmF3Q3VydmUgPSAoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGN1cnZlVHlwZSkge1xuICAgICAgICBjYXNlICdwb2x5bm9taWFsJzoge1xuICAgICAgICAgIGlmICghcGFyYW1ldGVycy5wb2x5bm9taWFsKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGNvZWZmaWNpZW50cyB9ID0gcGFyYW1ldGVycy5wb2x5bm9taWFsXG4gICAgICAgICAgZm9yIChsZXQgcHggPSAwOyBweCA8PSB3aWR0aDsgcHgrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKHB4KVxuICAgICAgICAgICAgY29uc3QgeSA9IGV2YWx1YXRlUG9seW5vbWlhbCh4LCBjb2VmZmljaWVudHMpXG4gICAgICAgICAgICBpZiAocHggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jlemllcic6IHtcbiAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBjb250cm9sIHBvaW50c1xuICAgICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNlZjQ0NDQnXG4gICAgICAgICAgY29udHJvbFBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjdHguYXJjKHRyYW5zZm9ybVgocG9pbnQueCksIHRyYW5zZm9ybVkocG9pbnQueSksIDQsIDAsIDIgKiBNYXRoLlBJKVxuICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERyYXcgY29udHJvbCBsaW5lc1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZGRkJ1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKGNvbnRyb2xQb2ludHNbaV0ueCksIHRyYW5zZm9ybVkoY29udHJvbFBvaW50c1tpXS55KSlcbiAgICAgICAgICAgIGN0eC5saW5lVG8odHJhbnNmb3JtWChjb250cm9sUG9pbnRzW2kgKyAxXS54KSwgdHJhbnNmb3JtWShjb250cm9sUG9pbnRzW2kgKyAxXS55KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBpbnRlcm1lZGlhdGUgcG9pbnRzIGFuZCBsaW5lcyBmb3IgZWFjaCBzdGVwIG9mIHRoZSBhbGdvcml0aG1cbiAgICAgICAgICBjb25zdCBzdGVwcyA9IDIwIC8vIE51bWJlciBvZiBzdGVwcyB0byBzaG93IGluIHRoZSB2aXN1YWxpemF0aW9uXG4gICAgICAgICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPD0gc3RlcHM7IHN0ZXArKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHN0ZXAgLyBzdGVwc1xuICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlUG9pbnRzID0gZ2V0SW50ZXJtZWRpYXRlUG9pbnRzKHQsIGNvbnRyb2xQb2ludHMpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgaW50ZXJtZWRpYXRlIHBvaW50cyBhbmQgbGluZXMgd2l0aCBkZWNyZWFzaW5nIG9wYWNpdHlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJtZWRpYXRlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGludGVybWVkaWF0ZVBvaW50c1tpXVxuICAgICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gMSAtIChpIC8gaW50ZXJtZWRpYXRlUG9pbnRzLmxlbmd0aCkgKiAwLjdcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIERyYXcgaW50ZXJtZWRpYXRlIHBvaW50c1xuICAgICAgICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBgcmdiYSgyMzksIDY4LCA2OCwgJHtvcGFjaXR5fSlgXG4gICAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGN0eC5hcmModHJhbnNmb3JtWChwb2ludC54KSwgdHJhbnNmb3JtWShwb2ludC55KSwgMiwgMCwgMiAqIE1hdGguUEkpXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBEcmF3IGludGVybWVkaWF0ZSBsaW5lc1xuICAgICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSgyMjEsIDIyMSwgMjIxLCAke29wYWNpdHl9KWBcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKHBvaW50c1tqXS54KSwgdHJhbnNmb3JtWShwb2ludHNbal0ueSkpXG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgocG9pbnRzW2ogKyAxXS54KSwgdHJhbnNmb3JtWShwb2ludHNbaiArIDFdLnkpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IGZpbmFsIGN1cnZlXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyMyNTYzZWInXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDJcbiAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZXZhbHVhdGVCZXppZXIodCwgY29udHJvbFBvaW50cylcbiAgICAgICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8odHJhbnNmb3JtWChwb2ludC54KSwgdHJhbnNmb3JtWShwb2ludC55KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8odHJhbnNmb3JtWChwb2ludC54KSwgdHJhbnNmb3JtWShwb2ludC55KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhbWV0cmljJzoge1xuICAgICAgICAgIGlmICghcGFyYW1ldGVycy5wYXJhbWV0cmljKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IHRNaW4sIHRNYXgsIHhGdW5jdGlvbiwgeUZ1bmN0aW9uLCB4U2NhbGUsIHlTY2FsZSB9ID0gcGFyYW1ldGVycy5wYXJhbWV0cmljXG4gICAgICAgICAgY29uc3Qgc3RlcHMgPSBNYXRoLm1heCgxMDAsIE1hdGguYWJzKHRNYXggLSB0TWluKSAqIDUwKVxuICAgICAgICAgIGNvbnN0IGR0ID0gKHRNYXggLSB0TWluKSAvIHN0ZXBzXG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3RlcHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRNaW4gKyBpICogZHRcbiAgICAgICAgICAgIGNvbnN0IHggPSBldmFsdWF0ZVBhcmFtZXRyaWNGdW5jdGlvbih0LCB4RnVuY3Rpb24sIHhTY2FsZSlcbiAgICAgICAgICAgIGNvbnN0IHkgPSBldmFsdWF0ZVBhcmFtZXRyaWNGdW5jdGlvbih0LCB5RnVuY3Rpb24sIHlTY2FsZSlcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8odHJhbnNmb3JtWCh4KSwgdHJhbnNmb3JtWSh5KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8odHJhbnNmb3JtWCh4KSwgdHJhbnNmb3JtWSh5KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cmlnb25vbWV0cmljJzoge1xuICAgICAgICAgIGlmICghcGFyYW1ldGVycy50cmlnb25vbWV0cmljKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwaGFzZSB9ID0gcGFyYW1ldGVycy50cmlnb25vbWV0cmljXG4gICAgICAgICAgZm9yIChsZXQgcHggPSAwOyBweCA8PSB3aWR0aDsgcHgrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKHB4KVxuICAgICAgICAgICAgY29uc3QgeSA9IGFtcGxpdHVkZSAqIE1hdGguc2luKGZyZXF1ZW5jeSAqIHggKyBwaGFzZSlcbiAgICAgICAgICAgIGlmIChweCA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHRyYW5zZm9ybVgoeCksIHRyYW5zZm9ybVkoeSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoeCksIHRyYW5zZm9ybVkoeSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXhwb25lbnRpYWwnOiB7XG4gICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmV4cG9uZW50aWFsKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGJhc2UsIGNvZWZmaWNpZW50LCB2ZXJ0aWNhbFNoaWZ0IH0gPSBwYXJhbWV0ZXJzLmV4cG9uZW50aWFsXG4gICAgICAgICAgZm9yIChsZXQgcHggPSAwOyBweCA8PSB3aWR0aDsgcHgrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKHB4KVxuICAgICAgICAgICAgY29uc3QgeSA9IGNvZWZmaWNpZW50ICogTWF0aC5wb3coYmFzZSwgeCkgKyB2ZXJ0aWNhbFNoaWZ0XG4gICAgICAgICAgICBpZiAocHggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZHJhd0N1cnZlKClcbiAgICBjdHguc3Ryb2tlKClcbiAgfSwgW2N1cnZlVHlwZSwgcGFyYW1ldGVycywgZGltZW5zaW9ucywgdHJhbnNmb3JtWCwgdHJhbnNmb3JtWSwgaW52ZXJzZVRyYW5zZm9ybVgsIGludmVyc2VUcmFuc2Zvcm1ZXSlcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXNcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbCByb3VuZGVkLWxnIGJvcmRlciBiZy1iYWNrZ3JvdW5kXCJcbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVNb3VzZURvd259XG4gICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgb25Nb3VzZVVwPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgb25Eb3VibGVDbGljaz17aGFuZGxlRG91YmxlQ2xpY2t9XG4gICAgICBvbkNvbnRleHRNZW51PXtoYW5kbGVDb250ZXh0TWVudX1cbiAgICAvPlxuICApXG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsImV2YWx1YXRlUG9seW5vbWlhbCIsIngiLCJjb2VmZmljaWVudHMiLCJyZWR1Y2UiLCJzdW0iLCJjb2VmZiIsImkiLCJNYXRoIiwicG93IiwibGVuZ3RoIiwiZXZhbHVhdGVCZXppZXIiLCJ0IiwicG9pbnRzIiwibmV3UG9pbnRzIiwicHVzaCIsInkiLCJnZXRJbnRlcm1lZGlhdGVQb2ludHMiLCJyZXN1bHQiLCJjdXJyZW50UG9pbnRzIiwiQ3VydmVDYW52YXMiLCJjdXJ2ZVR5cGUiLCJwYXJhbWV0ZXJzIiwib25QYXJhbWV0ZXJDaGFuZ2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsInVzZVN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkcmFnZ2luZ1BvaW50Iiwic2V0RHJhZ2dpbmdQb2ludCIsInBhZGRpbmciLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwidHJhbnNmb3JtWCIsInRyYW5zZm9ybVkiLCJpbnZlcnNlVHJhbnNmb3JtWCIsInB4IiwiaW52ZXJzZVRyYW5zZm9ybVkiLCJweSIsInVzZUVmZmVjdCIsInVwZGF0ZURpbWVuc2lvbnMiLCJjdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVNb3VzZURvd24iLCJlIiwiYmV6aWVyIiwiY2FudmFzIiwicmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImNvbnRyb2xQb2ludHMiLCJwb2ludEluZGV4IiwiZmluZEluZGV4IiwicG9pbnQiLCJkeCIsImR5Iiwic3FydCIsImluZGV4IiwiaGFuZGxlRG91YmxlQ2xpY2siLCJuZXdQb2ludCIsIm1pbkRpc3QiLCJJbmZpbml0eSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImRpc3QiLCJkaXN0YW5jZVRvTGluZVNlZ21lbnQiLCJzcGxpY2UiLCJoYW5kbGVDb250ZXh0TWVudSIsInByZXZlbnREZWZhdWx0IiwieDEiLCJ5MSIsIngyIiwieTIiLCJBIiwiQiIsIkMiLCJEIiwiZG90IiwibGVuU3EiLCJwYXJhbSIsInh4IiwieXkiLCJoYW5kbGVNb3VzZU1vdmUiLCJoYW5kbGVNb3VzZVVwIiwiY3R4IiwiZ2V0Q29udGV4dCIsInNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiY2VpbCIsImZsb29yIiwiZXZhbHVhdGVQYXJhbWV0cmljRnVuY3Rpb24iLCJmbiIsImNvcyIsInNpbiIsImRyYXdDdXJ2ZSIsInBvbHlub21pYWwiLCJzYXZlIiwiZmlsbFN0eWxlIiwiZm9yRWFjaCIsImFyYyIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJzdGVwcyIsInN0ZXAiLCJpbnRlcm1lZGlhdGVQb2ludHMiLCJvcGFjaXR5IiwiaiIsInBhcmFtZXRyaWMiLCJ0TWluIiwidE1heCIsInhGdW5jdGlvbiIsInlGdW5jdGlvbiIsInhTY2FsZSIsInlTY2FsZSIsIm1heCIsImFicyIsImR0IiwidHJpZ29ub21ldHJpYyIsImFtcGxpdHVkZSIsImZyZXF1ZW5jeSIsInBoYXNlIiwiZXhwb25lbnRpYWwiLCJiYXNlIiwiY29lZmZpY2llbnQiLCJ2ZXJ0aWNhbFNoaWZ0IiwicmVmIiwiY2xhc3NOYW1lIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uTW91c2VMZWF2ZSIsIm9uRG91YmxlQ2xpY2siLCJvbkNvbnRleHRNZW51Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/CurveCanvas.tsx\n"));

/***/ })

});