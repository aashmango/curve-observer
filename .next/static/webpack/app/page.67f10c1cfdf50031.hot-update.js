"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/CurveCanvas.tsx":
/*!****************************************!*\
  !*** ./app/components/CurveCanvas.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CurveCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction evaluatePolynomial(x, coefficients) {\n    return coefficients.reduce((sum, coeff, i)=>{\n        return sum + coeff * Math.pow(x, coefficients.length - 1 - i);\n    }, 0);\n}\nfunction evaluateBezier(t, points) {\n    if (points.length === 1) return points[0];\n    const newPoints = [];\n    for(let i = 0; i < points.length - 1; i++){\n        newPoints.push({\n            x: (1 - t) * points[i].x + t * points[i + 1].x,\n            y: (1 - t) * points[i].y + t * points[i + 1].y\n        });\n    }\n    return evaluateBezier(t, newPoints);\n}\nfunction CurveCanvas(param) {\n    let { curveType, parameters, onParameterChange } = param;\n    _s();\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [dimensions, setDimensions] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        width: 0,\n        height: 0\n    });\n    const [draggingPoint, setDraggingPoint] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n    const padding = 60;\n    const xMin = -10;\n    const xMax = 10;\n    const yMin = -10;\n    const yMax = 10;\n    const transformX = (x)=>(x - xMin) / (xMax - xMin) * (dimensions.width - 2 * padding) + padding;\n    const transformY = (y)=>dimensions.height - ((y - yMin) / (yMax - yMin) * (dimensions.height - 2 * padding) + padding);\n    const inverseTransformX = (px)=>(px - padding) / (dimensions.width - 2 * padding) * (xMax - xMin) + xMin;\n    const inverseTransformY = (py)=>yMax - (py - padding) / (dimensions.height - 2 * padding) * (yMax - yMin);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const updateDimensions = ()=>{\n            if (canvasRef.current) {\n                const { width, height } = canvasRef.current.getBoundingClientRect();\n                setDimensions({\n                    width,\n                    height\n                });\n                canvasRef.current.width = width;\n                canvasRef.current.height = height;\n            }\n        };\n        window.addEventListener(\"resize\", updateDimensions);\n        updateDimensions();\n        return ()=>window.removeEventListener(\"resize\", updateDimensions);\n    }, []);\n    const handleMouseDown = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1) {\n            setDraggingPoint({\n                index: pointIndex,\n                point: controlPoints[pointIndex]\n            });\n        }\n    };\n    const handleDoubleClick = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const newPoint = {\n            x,\n            y\n        };\n        // Find the closest line segment to insert the new point\n        let minDist = Infinity;\n        let insertIndex = 0;\n        for(let i = 0; i < controlPoints.length - 1; i++){\n            const p1 = controlPoints[i];\n            const p2 = controlPoints[i + 1];\n            const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);\n            if (dist < minDist) {\n                minDist = dist;\n                insertIndex = i + 1;\n            }\n        }\n        // If no line segments found, append to the end\n        if (controlPoints.length === 0) {\n            insertIndex = 0;\n        }\n        const newPoints = [\n            ...controlPoints\n        ];\n        newPoints.splice(insertIndex, 0, newPoint);\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleContextMenu = (e)=>{\n        if (curveType !== \"bezier\" || !parameters.bezier) return;\n        e.preventDefault();\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const { controlPoints } = parameters.bezier;\n        const pointIndex = controlPoints.findIndex((point)=>{\n            const dx = point.x - x;\n            const dy = point.y - y;\n            return Math.sqrt(dx * dx + dy * dy) < 0.5;\n        });\n        if (pointIndex !== -1 && controlPoints.length > 2) {\n            const newPoints = [\n                ...controlPoints\n            ];\n            newPoints.splice(pointIndex, 1);\n            onParameterChange({\n                bezier: {\n                    ...parameters.bezier,\n                    controlPoints: newPoints\n                }\n            });\n        }\n    };\n    const distanceToLineSegment = (x, y, x1, y1, x2, y2)=>{\n        const A = x - x1;\n        const B = y - y1;\n        const C = x2 - x1;\n        const D = y2 - y1;\n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        if (lenSq !== 0) {\n            param = dot / lenSq;\n        }\n        let xx, yy;\n        if (param < 0) {\n            xx = x1;\n            yy = y1;\n        } else if (param > 1) {\n            xx = x2;\n            yy = y2;\n        } else {\n            xx = x1 + param * C;\n            yy = y1 + param * D;\n        }\n        const dx = x - xx;\n        const dy = y - yy;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    const handleMouseMove = (e)=>{\n        if (!draggingPoint || !parameters.bezier) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = inverseTransformX(e.clientX - rect.left);\n        const y = inverseTransformY(e.clientY - rect.top);\n        const newPoints = [\n            ...parameters.bezier.controlPoints\n        ];\n        newPoints[draggingPoint.index] = {\n            x,\n            y\n        };\n        onParameterChange({\n            bezier: {\n                ...parameters.bezier,\n                controlPoints: newPoints\n            }\n        });\n    };\n    const handleMouseUp = ()=>{\n        setDraggingPoint(null);\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const { width, height } = dimensions;\n        // Set canvas scale for retina displays\n        const scale = window.devicePixelRatio;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        ctx.scale(scale, scale);\n        // Clear canvas\n        ctx.clearRect(0, 0, width, height);\n        // Draw axes\n        ctx.beginPath();\n        ctx.strokeStyle = \"#666\";\n        ctx.lineWidth = 1;\n        // X-axis\n        ctx.moveTo(padding, transformY(0));\n        ctx.lineTo(width - padding, transformY(0));\n        // Y-axis\n        ctx.moveTo(transformX(0), height - padding);\n        ctx.lineTo(transformX(0), padding);\n        ctx.stroke();\n        // Draw grid\n        ctx.beginPath();\n        ctx.strokeStyle = \"#ddd\";\n        ctx.lineWidth = 0.5;\n        for(let x = Math.ceil(xMin); x <= Math.floor(xMax); x++){\n            if (x === 0) continue;\n            ctx.moveTo(transformX(x), padding);\n            ctx.lineTo(transformX(x), height - padding);\n        }\n        for(let y = Math.ceil(yMin); y <= Math.floor(yMax); y++){\n            if (y === 0) continue;\n            ctx.moveTo(padding, transformY(y));\n            ctx.lineTo(width - padding, transformY(y));\n        }\n        ctx.stroke();\n        // Draw curve\n        ctx.beginPath();\n        ctx.strokeStyle = \"#2563eb\";\n        ctx.lineWidth = 2;\n        const evaluateParametricFunction = function(t, fn) {\n            let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n            switch(fn){\n                case \"cos\":\n                    return scale * Math.cos(t);\n                case \"sin\":\n                    return scale * Math.sin(t);\n                case \"t\":\n                    return scale * t;\n                case \"t^2\":\n                    return scale * t * t;\n                default:\n                    return 0;\n            }\n        };\n        const drawCurve = ()=>{\n            switch(curveType){\n                case \"polynomial\":\n                    {\n                        if (!parameters.polynomial) return;\n                        const { coefficients } = parameters.polynomial;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = evaluatePolynomial(x, coefficients);\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"bezier\":\n                    {\n                        if (!parameters.bezier) return;\n                        const { controlPoints } = parameters.bezier;\n                        // Draw control points\n                        ctx.save();\n                        ctx.fillStyle = \"#ef4444\";\n                        controlPoints.forEach((point)=>{\n                            ctx.beginPath();\n                            ctx.arc(transformX(point.x), transformY(point.y), 4, 0, 2 * Math.PI);\n                            ctx.fill();\n                        });\n                        ctx.restore();\n                        // Draw control lines\n                        ctx.beginPath();\n                        ctx.strokeStyle = \"#ddd\";\n                        ctx.lineWidth = 1;\n                        for(let i = 0; i < controlPoints.length - 1; i++){\n                            ctx.moveTo(transformX(controlPoints[i].x), transformY(controlPoints[i].y));\n                            ctx.lineTo(transformX(controlPoints[i + 1].x), transformY(controlPoints[i + 1].y));\n                        }\n                        ctx.stroke();\n                        // Draw curve\n                        ctx.beginPath();\n                        ctx.strokeStyle = \"#2563eb\";\n                        ctx.lineWidth = 2;\n                        for(let t = 0; t <= 1; t += 0.01){\n                            const point = evaluateBezier(t, controlPoints);\n                            if (t === 0) {\n                                ctx.moveTo(transformX(point.x), transformY(point.y));\n                            } else {\n                                ctx.lineTo(transformX(point.x), transformY(point.y));\n                            }\n                        }\n                        break;\n                    }\n                case \"parametric\":\n                    {\n                        if (!parameters.parametric) return;\n                        const { tMin, tMax, xFunction, yFunction, xScale, yScale } = parameters.parametric;\n                        const steps = Math.max(100, Math.abs(tMax - tMin) * 50);\n                        const dt = (tMax - tMin) / steps;\n                        for(let i = 0; i <= steps; i++){\n                            const t = tMin + i * dt;\n                            const x = evaluateParametricFunction(t, xFunction, xScale);\n                            const y = evaluateParametricFunction(t, yFunction, yScale);\n                            if (i === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"trigonometric\":\n                    {\n                        if (!parameters.trigonometric) return;\n                        const { amplitude, frequency, phase } = parameters.trigonometric;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = amplitude * Math.sin(frequency * x + phase);\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n                case \"exponential\":\n                    {\n                        if (!parameters.exponential) return;\n                        const { base, coefficient, verticalShift } = parameters.exponential;\n                        for(let px = 0; px <= width; px++){\n                            const x = inverseTransformX(px);\n                            const y = coefficient * Math.pow(base, x) + verticalShift;\n                            if (px === 0) {\n                                ctx.moveTo(transformX(x), transformY(y));\n                            } else {\n                                ctx.lineTo(transformX(x), transformY(y));\n                            }\n                        }\n                        break;\n                    }\n            }\n        };\n        drawCurve();\n        ctx.stroke();\n    }, [\n        curveType,\n        parameters,\n        dimensions,\n        transformX,\n        transformY,\n        inverseTransformX,\n        inverseTransformY\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"h-full w-full rounded-lg border bg-background\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu\n    }, void 0, false, {\n        fileName: \"/Users/agoghari/curve-explorer/app/components/CurveCanvas.tsx\",\n        lineNumber: 397,\n        columnNumber: 5\n    }, this);\n}\n_s(CurveCanvas, \"YabCTyuMquUxp7gR26CrjMOV5Fg=\");\n_c = CurveCanvas;\nvar _c;\n$RefreshReg$(_c, \"CurveCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0N1cnZlQ2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFOEI7QUFTOUIsU0FBU0MsbUJBQW1CQyxDQUFTLEVBQUVDLFlBQXNCO0lBQzNELE9BQU9BLGFBQWFDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFPQztRQUN0QyxPQUFPRixNQUFNQyxRQUFRRSxLQUFLQyxHQUFHLENBQUNQLEdBQUdDLGFBQWFPLE1BQU0sR0FBRyxJQUFJSDtJQUM3RCxHQUFHO0FBQ0w7QUFFQSxTQUFTSSxlQUFlQyxDQUFTLEVBQUVDLE1BQWU7SUFDaEQsSUFBSUEsT0FBT0gsTUFBTSxLQUFLLEdBQUcsT0FBT0csTUFBTSxDQUFDLEVBQUU7SUFDekMsTUFBTUMsWUFBcUIsRUFBRTtJQUM3QixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSU0sT0FBT0gsTUFBTSxHQUFHLEdBQUdILElBQUs7UUFDMUNPLFVBQVVDLElBQUksQ0FBQztZQUNiYixHQUFHLENBQUMsSUFBSVUsQ0FBQUEsSUFBS0MsTUFBTSxDQUFDTixFQUFFLENBQUNMLENBQUMsR0FBR1UsSUFBSUMsTUFBTSxDQUFDTixJQUFJLEVBQUUsQ0FBQ0wsQ0FBQztZQUM5Q2MsR0FBRyxDQUFDLElBQUlKLENBQUFBLElBQUtDLE1BQU0sQ0FBQ04sRUFBRSxDQUFDUyxDQUFDLEdBQUdKLElBQUlDLE1BQU0sQ0FBQ04sSUFBSSxFQUFFLENBQUNTLENBQUM7UUFDaEQ7SUFDRjtJQUNBLE9BQU9MLGVBQWVDLEdBQUdFO0FBQzNCO0FBRWUsU0FBU0csWUFBWSxLQUE4RDtRQUE5RCxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsaUJBQWlCLEVBQW9CLEdBQTlEOztJQUNsQyxNQUFNQyxZQUFZckIseUNBQVksQ0FBb0I7SUFDbEQsTUFBTSxDQUFDdUIsWUFBWUMsY0FBYyxHQUFHeEIsMkNBQWMsQ0FBQztRQUFFMEIsT0FBTztRQUFHQyxRQUFRO0lBQUU7SUFD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OUYsT0FBTyxHQUFHO2dDQUNac0QsSUFBSVEsTUFBTSxDQUFDakUsV0FBV2pDLElBQUlrQyxXQUFXcEI7NEJBQ3ZDLE9BQU87Z0NBQ0w0RSxJQUFJUyxNQUFNLENBQUNsRSxXQUFXakMsSUFBSWtDLFdBQVdwQjs0QkFDdkM7d0JBQ0Y7d0JBQ0E7b0JBQ0Y7Z0JBQ0EsS0FBSztvQkFBZTt3QkFDbEIsSUFBSSxDQUFDRyxXQUFXa0gsV0FBVyxFQUFFO3dCQUM3QixNQUFNLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUUsR0FBR3JILFdBQVdrSCxXQUFXO3dCQUNuRSxJQUFLLElBQUkvRixLQUFLLEdBQUdBLE1BQU1aLE9BQU9ZLEtBQU07NEJBQ2xDLE1BQU1wQyxJQUFJbUMsa0JBQWtCQzs0QkFDNUIsTUFBTXRCLElBQUl1SCxjQUFjL0gsS0FBS0MsR0FBRyxDQUFDNkgsTUFBTXBJLEtBQUtzSTs0QkFDNUMsSUFBSWxHLE9BQU8sR0FBRztnQ0FDWnNELElBQUlRLE1BQU0sQ0FBQ2pFLFdBQVdqQyxJQUFJa0MsV0FBV3BCOzRCQUN2QyxPQUFPO2dDQUNMNEUsSUFBSVMsTUFBTSxDQUFDbEUsV0FBV2pDLElBQUlrQyxXQUFXcEI7NEJBQ3ZDO3dCQUNGO3dCQUNBO29CQUNGO1lBQ0Y7UUFDRjtRQUVBNkY7UUFDQWpCLElBQUlVLE1BQU07SUFDWixHQUFHO1FBQUNwRjtRQUFXQztRQUFZSTtRQUFZWTtRQUFZQztRQUFZQztRQUFtQkU7S0FBa0I7SUFFcEcscUJBQ0UsOERBQUNZO1FBQ0NzRixLQUFLcEg7UUFDTHFILFdBQVU7UUFDVkMsYUFBYTNGO1FBQ2I0RixhQUFhbEQ7UUFDYm1ELFdBQVdsRDtRQUNYbUQsY0FBY25EO1FBQ2RvRCxlQUFlOUU7UUFDZitFLGVBQWVyRTs7Ozs7O0FBR3JCO0dBMVh3QjFEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL0N1cnZlQ2FudmFzLnRzeD9mNDUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEN1cnZlUGFyYW1ldGVycywgQ3VydmVUeXBlLCBQb2ludCB9IGZyb20gJy4uL3R5cGVzL2N1cnZlcydcblxudHlwZSBDdXJ2ZUNhbnZhc1Byb3BzID0ge1xuICBjdXJ2ZVR5cGU6IEN1cnZlVHlwZVxuICBwYXJhbWV0ZXJzOiBQYXJ0aWFsPEN1cnZlUGFyYW1ldGVycz5cbiAgb25QYXJhbWV0ZXJDaGFuZ2U6IChwYXJhbXM6IFBhcnRpYWw8Q3VydmVQYXJhbWV0ZXJzPikgPT4gdm9pZFxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZVBvbHlub21pYWwoeDogbnVtYmVyLCBjb2VmZmljaWVudHM6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNvZWZmaWNpZW50cy5yZWR1Y2UoKHN1bSwgY29lZmYsIGkpID0+IHtcbiAgICByZXR1cm4gc3VtICsgY29lZmYgKiBNYXRoLnBvdyh4LCBjb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGkpXG4gIH0sIDApXG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlQmV6aWVyKHQ6IG51bWJlciwgcG9pbnRzOiBQb2ludFtdKTogUG9pbnQge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBvaW50c1swXVxuICBjb25zdCBuZXdQb2ludHM6IFBvaW50W10gPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBuZXdQb2ludHMucHVzaCh7XG4gICAgICB4OiAoMSAtIHQpICogcG9pbnRzW2ldLnggKyB0ICogcG9pbnRzW2kgKyAxXS54LFxuICAgICAgeTogKDEgLSB0KSAqIHBvaW50c1tpXS55ICsgdCAqIHBvaW50c1tpICsgMV0ueSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBldmFsdWF0ZUJlemllcih0LCBuZXdQb2ludHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN1cnZlQ2FudmFzKHsgY3VydmVUeXBlLCBwYXJhbWV0ZXJzLCBvblBhcmFtZXRlckNoYW5nZSB9OiBDdXJ2ZUNhbnZhc1Byb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gUmVhY3QudXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pXG4gIGNvbnN0IFtkcmFnZ2luZ1BvaW50LCBzZXREcmFnZ2luZ1BvaW50XSA9IFJlYWN0LnVzZVN0YXRlPHsgaW5kZXg6IG51bWJlcjsgcG9pbnQ6IFBvaW50IH0gfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IHBhZGRpbmcgPSA2MFxuICBjb25zdCB4TWluID0gLTEwXG4gIGNvbnN0IHhNYXggPSAxMFxuICBjb25zdCB5TWluID0gLTEwXG4gIGNvbnN0IHlNYXggPSAxMFxuXG4gIGNvbnN0IHRyYW5zZm9ybVggPSAoeDogbnVtYmVyKSA9PiAoKHggLSB4TWluKSAvICh4TWF4IC0geE1pbikpICogKGRpbWVuc2lvbnMud2lkdGggLSAyICogcGFkZGluZykgKyBwYWRkaW5nXG4gIGNvbnN0IHRyYW5zZm9ybVkgPSAoeTogbnVtYmVyKSA9PiBkaW1lbnNpb25zLmhlaWdodCAtICgoKHkgLSB5TWluKSAvICh5TWF4IC0geU1pbikpICogKGRpbWVuc2lvbnMuaGVpZ2h0IC0gMiAqIHBhZGRpbmcpICsgcGFkZGluZylcbiAgY29uc3QgaW52ZXJzZVRyYW5zZm9ybVggPSAocHg6IG51bWJlcikgPT4gKChweCAtIHBhZGRpbmcpIC8gKGRpbWVuc2lvbnMud2lkdGggLSAyICogcGFkZGluZykpICogKHhNYXggLSB4TWluKSArIHhNaW5cbiAgY29uc3QgaW52ZXJzZVRyYW5zZm9ybVkgPSAocHk6IG51bWJlcikgPT4geU1heCAtICgocHkgLSBwYWRkaW5nKSAvIChkaW1lbnNpb25zLmhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKiAoeU1heCAtIHlNaW4pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgc2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSlcbiAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSB3aWR0aFxuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucylcbiAgICB1cGRhdGVEaW1lbnNpb25zKClcblxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucylcbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlTW91c2VEb3duID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IHBvaW50SW5kZXggPSBjb250cm9sUG9pbnRzLmZpbmRJbmRleCgocG9pbnQpID0+IHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnQueCAtIHhcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnQueSAtIHlcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDwgMC41XG4gICAgfSlcblxuICAgIGlmIChwb2ludEluZGV4ICE9PSAtMSkge1xuICAgICAgc2V0RHJhZ2dpbmdQb2ludCh7IGluZGV4OiBwb2ludEluZGV4LCBwb2ludDogY29udHJvbFBvaW50c1twb2ludEluZGV4XSB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZURvdWJsZUNsaWNrID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzIH0gPSBwYXJhbWV0ZXJzLmJlemllclxuICAgIGNvbnN0IG5ld1BvaW50ID0geyB4LCB5IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgbGluZSBzZWdtZW50IHRvIGluc2VydCB0aGUgbmV3IHBvaW50XG4gICAgbGV0IG1pbkRpc3QgPSBJbmZpbml0eVxuICAgIGxldCBpbnNlcnRJbmRleCA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHAxID0gY29udHJvbFBvaW50c1tpXVxuICAgICAgY29uc3QgcDIgPSBjb250cm9sUG9pbnRzW2kgKyAxXVxuICAgICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBwMS54LCBwMS55LCBwMi54LCBwMi55KVxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBsaW5lIHNlZ21lbnRzIGZvdW5kLCBhcHBlbmQgdG8gdGhlIGVuZFxuICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0SW5kZXggPSAwXG4gICAgfVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpXG5cbiAgICBvblBhcmFtZXRlckNoYW5nZSh7XG4gICAgICBiZXppZXI6IHtcbiAgICAgICAgLi4ucGFyYW1ldGVycy5iZXppZXIsXG4gICAgICAgIGNvbnRyb2xQb2ludHM6IG5ld1BvaW50cyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKGN1cnZlVHlwZSAhPT0gJ2JlemllcicgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKGUuY2xpZW50WCAtIHJlY3QubGVmdClcbiAgICBjb25zdCB5ID0gaW52ZXJzZVRyYW5zZm9ybVkoZS5jbGllbnRZIC0gcmVjdC50b3ApXG5cbiAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgY29uc3QgcG9pbnRJbmRleCA9IGNvbnRyb2xQb2ludHMuZmluZEluZGV4KChwb2ludCkgPT4ge1xuICAgICAgY29uc3QgZHggPSBwb2ludC54IC0geFxuICAgICAgY29uc3QgZHkgPSBwb2ludC55IC0geVxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgPCAwLjVcbiAgICB9KVxuXG4gICAgaWYgKHBvaW50SW5kZXggIT09IC0xICYmIGNvbnRyb2xQb2ludHMubGVuZ3RoID4gMikge1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLmNvbnRyb2xQb2ludHNdXG4gICAgICBuZXdQb2ludHMuc3BsaWNlKHBvaW50SW5kZXgsIDEpXG5cbiAgICAgIG9uUGFyYW1ldGVyQ2hhbmdlKHtcbiAgICAgICAgYmV6aWVyOiB7XG4gICAgICAgICAgLi4ucGFyYW1ldGVycy5iZXppZXIsXG4gICAgICAgICAgY29udHJvbFBvaW50czogbmV3UG9pbnRzLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXN0YW5jZVRvTGluZVNlZ21lbnQgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IEEgPSB4IC0geDFcbiAgICBjb25zdCBCID0geSAtIHkxXG4gICAgY29uc3QgQyA9IHgyIC0geDFcbiAgICBjb25zdCBEID0geTIgLSB5MVxuXG4gICAgY29uc3QgZG90ID0gQSAqIEMgKyBCICogRFxuICAgIGNvbnN0IGxlblNxID0gQyAqIEMgKyBEICogRFxuICAgIGxldCBwYXJhbSA9IC0xXG5cbiAgICBpZiAobGVuU3EgIT09IDApIHtcbiAgICAgIHBhcmFtID0gZG90IC8gbGVuU3FcbiAgICB9XG5cbiAgICBsZXQgeHgsIHl5XG5cbiAgICBpZiAocGFyYW0gPCAwKSB7XG4gICAgICB4eCA9IHgxXG4gICAgICB5eSA9IHkxXG4gICAgfSBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgIHh4ID0geDJcbiAgICAgIHl5ID0geTJcbiAgICB9IGVsc2Uge1xuICAgICAgeHggPSB4MSArIHBhcmFtICogQ1xuICAgICAgeXkgPSB5MSArIHBhcmFtICogRFxuICAgIH1cblxuICAgIGNvbnN0IGR4ID0geCAtIHh4XG4gICAgY29uc3QgZHkgPSB5IC0geXlcblxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gIH1cblxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nUG9pbnQgfHwgIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChlLmNsaWVudFggLSByZWN0LmxlZnQpXG4gICAgY29uc3QgeSA9IGludmVyc2VUcmFuc2Zvcm1ZKGUuY2xpZW50WSAtIHJlY3QudG9wKVxuXG4gICAgY29uc3QgbmV3UG9pbnRzID0gWy4uLnBhcmFtZXRlcnMuYmV6aWVyLmNvbnRyb2xQb2ludHNdXG4gICAgbmV3UG9pbnRzW2RyYWdnaW5nUG9pbnQuaW5kZXhdID0geyB4LCB5IH1cblxuICAgIG9uUGFyYW1ldGVyQ2hhbmdlKHtcbiAgICAgIGJlemllcjoge1xuICAgICAgICAuLi5wYXJhbWV0ZXJzLmJlemllcixcbiAgICAgICAgY29udHJvbFBvaW50czogbmV3UG9pbnRzLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICBzZXREcmFnZ2luZ1BvaW50KG51bGwpXG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBpZiAoIWN0eCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbWVuc2lvbnNcblxuICAgIC8vIFNldCBjYW52YXMgc2NhbGUgZm9yIHJldGluYSBkaXNwbGF5c1xuICAgIGNvbnN0IHNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHNjYWxlXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHNjYWxlXG4gICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSlcblxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcblxuICAgIC8vIERyYXcgYXhlc1xuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNjY2J1xuICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgXG4gICAgLy8gWC1heGlzXG4gICAgY3R4Lm1vdmVUbyhwYWRkaW5nLCB0cmFuc2Zvcm1ZKDApKVxuICAgIGN0eC5saW5lVG8od2lkdGggLSBwYWRkaW5nLCB0cmFuc2Zvcm1ZKDApKVxuICAgIFxuICAgIC8vIFktYXhpc1xuICAgIGN0eC5tb3ZlVG8odHJhbnNmb3JtWCgwKSwgaGVpZ2h0IC0gcGFkZGluZylcbiAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoMCksIHBhZGRpbmcpXG4gICAgXG4gICAgY3R4LnN0cm9rZSgpXG5cbiAgICAvLyBEcmF3IGdyaWRcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2RkZCdcbiAgICBjdHgubGluZVdpZHRoID0gMC41XG5cbiAgICBmb3IgKGxldCB4ID0gTWF0aC5jZWlsKHhNaW4pOyB4IDw9IE1hdGguZmxvb3IoeE1heCk7IHgrKykge1xuICAgICAgaWYgKHggPT09IDApIGNvbnRpbnVlXG4gICAgICBjdHgubW92ZVRvKHRyYW5zZm9ybVgoeCksIHBhZGRpbmcpXG4gICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoeCksIGhlaWdodCAtIHBhZGRpbmcpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgeSA9IE1hdGguY2VpbCh5TWluKTsgeSA8PSBNYXRoLmZsb29yKHlNYXgpOyB5KyspIHtcbiAgICAgIGlmICh5ID09PSAwKSBjb250aW51ZVxuICAgICAgY3R4Lm1vdmVUbyhwYWRkaW5nLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgY3R4LmxpbmVUbyh3aWR0aCAtIHBhZGRpbmcsIHRyYW5zZm9ybVkoeSkpXG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZSgpXG5cbiAgICAvLyBEcmF3IGN1cnZlXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyMyNTYzZWInXG4gICAgY3R4LmxpbmVXaWR0aCA9IDJcblxuICAgIGNvbnN0IGV2YWx1YXRlUGFyYW1ldHJpY0Z1bmN0aW9uID0gKHQ6IG51bWJlciwgZm46IHN0cmluZywgc2NhbGU6IG51bWJlciA9IDEpOiBudW1iZXIgPT4ge1xuICAgICAgc3dpdGNoIChmbikge1xuICAgICAgICBjYXNlICdjb3MnOlxuICAgICAgICAgIHJldHVybiBzY2FsZSAqIE1hdGguY29zKHQpXG4gICAgICAgIGNhc2UgJ3Npbic6XG4gICAgICAgICAgcmV0dXJuIHNjYWxlICogTWF0aC5zaW4odClcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgcmV0dXJuIHNjYWxlICogdFxuICAgICAgICBjYXNlICd0XjInOlxuICAgICAgICAgIHJldHVybiBzY2FsZSAqIHQgKiB0XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkcmF3Q3VydmUgPSAoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGN1cnZlVHlwZSkge1xuICAgICAgICBjYXNlICdwb2x5bm9taWFsJzoge1xuICAgICAgICAgIGlmICghcGFyYW1ldGVycy5wb2x5bm9taWFsKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGNvZWZmaWNpZW50cyB9ID0gcGFyYW1ldGVycy5wb2x5bm9taWFsXG4gICAgICAgICAgZm9yIChsZXQgcHggPSAwOyBweCA8PSB3aWR0aDsgcHgrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGludmVyc2VUcmFuc2Zvcm1YKHB4KVxuICAgICAgICAgICAgY29uc3QgeSA9IGV2YWx1YXRlUG9seW5vbWlhbCh4LCBjb2VmZmljaWVudHMpXG4gICAgICAgICAgICBpZiAocHggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jlemllcic6IHtcbiAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMuYmV6aWVyKSByZXR1cm5cbiAgICAgICAgICBjb25zdCB7IGNvbnRyb2xQb2ludHMgfSA9IHBhcmFtZXRlcnMuYmV6aWVyXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBjb250cm9sIHBvaW50c1xuICAgICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNlZjQ0NDQnXG4gICAgICAgICAgY29udHJvbFBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICBjdHguYXJjKHRyYW5zZm9ybVgocG9pbnQueCksIHRyYW5zZm9ybVkocG9pbnQueSksIDQsIDAsIDIgKiBNYXRoLlBJKVxuICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERyYXcgY29udHJvbCBsaW5lc1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZGRkJ1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKGNvbnRyb2xQb2ludHNbaV0ueCksIHRyYW5zZm9ybVkoY29udHJvbFBvaW50c1tpXS55KSlcbiAgICAgICAgICAgIGN0eC5saW5lVG8odHJhbnNmb3JtWChjb250cm9sUG9pbnRzW2kgKyAxXS54KSwgdHJhbnNmb3JtWShjb250cm9sUG9pbnRzW2kgKyAxXS55KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBjdXJ2ZVxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMjU2M2ViJ1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyXG4gICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IGV2YWx1YXRlQmV6aWVyKHQsIGNvbnRyb2xQb2ludHMpXG4gICAgICAgICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHRyYW5zZm9ybVgocG9pbnQueCksIHRyYW5zZm9ybVkocG9pbnQueSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgocG9pbnQueCksIHRyYW5zZm9ybVkocG9pbnQueSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGFyYW1ldHJpYyc6IHtcbiAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMucGFyYW1ldHJpYykgcmV0dXJuXG4gICAgICAgICAgY29uc3QgeyB0TWluLCB0TWF4LCB4RnVuY3Rpb24sIHlGdW5jdGlvbiwgeFNjYWxlLCB5U2NhbGUgfSA9IHBhcmFtZXRlcnMucGFyYW1ldHJpY1xuICAgICAgICAgIGNvbnN0IHN0ZXBzID0gTWF0aC5tYXgoMTAwLCBNYXRoLmFicyh0TWF4IC0gdE1pbikgKiA1MClcbiAgICAgICAgICBjb25zdCBkdCA9ICh0TWF4IC0gdE1pbikgLyBzdGVwc1xuICAgICAgICAgIFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0TWluICsgaSAqIGR0XG4gICAgICAgICAgICBjb25zdCB4ID0gZXZhbHVhdGVQYXJhbWV0cmljRnVuY3Rpb24odCwgeEZ1bmN0aW9uLCB4U2NhbGUpXG4gICAgICAgICAgICBjb25zdCB5ID0gZXZhbHVhdGVQYXJhbWV0cmljRnVuY3Rpb24odCwgeUZ1bmN0aW9uLCB5U2NhbGUpXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHRyYW5zZm9ybVgoeCksIHRyYW5zZm9ybVkoeSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHRyYW5zZm9ybVgoeCksIHRyYW5zZm9ybVkoeSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndHJpZ29ub21ldHJpYyc6IHtcbiAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMudHJpZ29ub21ldHJpYykgcmV0dXJuXG4gICAgICAgICAgY29uc3QgeyBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcGhhc2UgfSA9IHBhcmFtZXRlcnMudHJpZ29ub21ldHJpY1xuICAgICAgICAgIGZvciAobGV0IHB4ID0gMDsgcHggPD0gd2lkdGg7IHB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChweClcbiAgICAgICAgICAgIGNvbnN0IHkgPSBhbXBsaXR1ZGUgKiBNYXRoLnNpbihmcmVxdWVuY3kgKiB4ICsgcGhhc2UpXG4gICAgICAgICAgICBpZiAocHggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmFuc2Zvcm1YKHgpLCB0cmFuc2Zvcm1ZKHkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2V4cG9uZW50aWFsJzoge1xuICAgICAgICAgIGlmICghcGFyYW1ldGVycy5leHBvbmVudGlhbCkgcmV0dXJuXG4gICAgICAgICAgY29uc3QgeyBiYXNlLCBjb2VmZmljaWVudCwgdmVydGljYWxTaGlmdCB9ID0gcGFyYW1ldGVycy5leHBvbmVudGlhbFxuICAgICAgICAgIGZvciAobGV0IHB4ID0gMDsgcHggPD0gd2lkdGg7IHB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBpbnZlcnNlVHJhbnNmb3JtWChweClcbiAgICAgICAgICAgIGNvbnN0IHkgPSBjb2VmZmljaWVudCAqIE1hdGgucG93KGJhc2UsIHgpICsgdmVydGljYWxTaGlmdFxuICAgICAgICAgICAgaWYgKHB4ID09PSAwKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8odHJhbnNmb3JtWCh4KSwgdHJhbnNmb3JtWSh5KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8odHJhbnNmb3JtWCh4KSwgdHJhbnNmb3JtWSh5KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdDdXJ2ZSgpXG4gICAgY3R4LnN0cm9rZSgpXG4gIH0sIFtjdXJ2ZVR5cGUsIHBhcmFtZXRlcnMsIGRpbWVuc2lvbnMsIHRyYW5zZm9ybVgsIHRyYW5zZm9ybVksIGludmVyc2VUcmFuc2Zvcm1YLCBpbnZlcnNlVHJhbnNmb3JtWV0pXG5cbiAgcmV0dXJuIChcbiAgICA8Y2FudmFzXG4gICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgIGNsYXNzTmFtZT1cImgtZnVsbCB3LWZ1bGwgcm91bmRlZC1sZyBib3JkZXIgYmctYmFja2dyb3VuZFwiXG4gICAgICBvbk1vdXNlRG93bj17aGFuZGxlTW91c2VEb3dufVxuICAgICAgb25Nb3VzZU1vdmU9e2hhbmRsZU1vdXNlTW92ZX1cbiAgICAgIG9uTW91c2VVcD17aGFuZGxlTW91c2VVcH1cbiAgICAgIG9uTW91c2VMZWF2ZT17aGFuZGxlTW91c2VVcH1cbiAgICAgIG9uRG91YmxlQ2xpY2s9e2hhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgb25Db250ZXh0TWVudT17aGFuZGxlQ29udGV4dE1lbnV9XG4gICAgLz5cbiAgKVxufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJldmFsdWF0ZVBvbHlub21pYWwiLCJ4IiwiY29lZmZpY2llbnRzIiwicmVkdWNlIiwic3VtIiwiY29lZmYiLCJpIiwiTWF0aCIsInBvdyIsImxlbmd0aCIsImV2YWx1YXRlQmV6aWVyIiwidCIsInBvaW50cyIsIm5ld1BvaW50cyIsInB1c2giLCJ5IiwiQ3VydmVDYW52YXMiLCJjdXJ2ZVR5cGUiLCJwYXJhbWV0ZXJzIiwib25QYXJhbWV0ZXJDaGFuZ2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsInVzZVN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkcmFnZ2luZ1BvaW50Iiwic2V0RHJhZ2dpbmdQb2ludCIsInBhZGRpbmciLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwidHJhbnNmb3JtWCIsInRyYW5zZm9ybVkiLCJpbnZlcnNlVHJhbnNmb3JtWCIsInB4IiwiaW52ZXJzZVRyYW5zZm9ybVkiLCJweSIsInVzZUVmZmVjdCIsInVwZGF0ZURpbWVuc2lvbnMiLCJjdXJyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVNb3VzZURvd24iLCJlIiwiYmV6aWVyIiwiY2FudmFzIiwicmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImNvbnRyb2xQb2ludHMiLCJwb2ludEluZGV4IiwiZmluZEluZGV4IiwicG9pbnQiLCJkeCIsImR5Iiwic3FydCIsImluZGV4IiwiaGFuZGxlRG91YmxlQ2xpY2siLCJuZXdQb2ludCIsIm1pbkRpc3QiLCJJbmZpbml0eSIsImluc2VydEluZGV4IiwicDEiLCJwMiIsImRpc3QiLCJkaXN0YW5jZVRvTGluZVNlZ21lbnQiLCJzcGxpY2UiLCJoYW5kbGVDb250ZXh0TWVudSIsInByZXZlbnREZWZhdWx0IiwieDEiLCJ5MSIsIngyIiwieTIiLCJBIiwiQiIsIkMiLCJEIiwiZG90IiwibGVuU3EiLCJwYXJhbSIsInh4IiwieXkiLCJoYW5kbGVNb3VzZU1vdmUiLCJoYW5kbGVNb3VzZVVwIiwiY3R4IiwiZ2V0Q29udGV4dCIsInNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiY2VpbCIsImZsb29yIiwiZXZhbHVhdGVQYXJhbWV0cmljRnVuY3Rpb24iLCJmbiIsImNvcyIsInNpbiIsImRyYXdDdXJ2ZSIsInBvbHlub21pYWwiLCJzYXZlIiwiZmlsbFN0eWxlIiwiZm9yRWFjaCIsImFyYyIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJwYXJhbWV0cmljIiwidE1pbiIsInRNYXgiLCJ4RnVuY3Rpb24iLCJ5RnVuY3Rpb24iLCJ4U2NhbGUiLCJ5U2NhbGUiLCJzdGVwcyIsIm1heCIsImFicyIsImR0IiwidHJpZ29ub21ldHJpYyIsImFtcGxpdHVkZSIsImZyZXF1ZW5jeSIsInBoYXNlIiwiZXhwb25lbnRpYWwiLCJiYXNlIiwiY29lZmZpY2llbnQiLCJ2ZXJ0aWNhbFNoaWZ0IiwicmVmIiwiY2xhc3NOYW1lIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uTW91c2VMZWF2ZSIsIm9uRG91YmxlQ2xpY2siLCJvbkNvbnRleHRNZW51Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/CurveCanvas.tsx\n"));

/***/ })

});